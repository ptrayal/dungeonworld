{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"NULL",
				"NULL"
			],
			[
				"pObj",
				"pObjIndex"
			],
			[
				"pO",
				"pObjIndex"
			],
			[
				"pMob",
				"pMobIndex"
			],
			[
				"IS_N",
				"IS_NULLSTR"
			],
			[
				"file",
				"file_name"
			],
			[
				"Write",
				"WriteNumber"
			],
			[
				"show",
				"showstr_point"
			],
			[
				"IS",
				"IS_NULLSTR"
			],
			[
				"WRite",
				"WriteNumber"
			],
			[
				"WR",
				"WriteLong"
			],
			[
				"n",
				"n"
			],
			[
				"pr",
				"profession"
			],
			[
				"race",
				"race_lookup"
			],
			[
				"ST",
				"STAT_STR"
			],
			[
				"user",
				"user"
			],
			[
				"STAT",
				"STAT_STA"
			],
			[
				"stat",
				"statcount"
			],
			[
				"send",
				"send_to_char"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "Searching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\act_info.c:\n  196  	if (prgpstrShow[iShow][0] == '\\0')\n  197  	{\n  198: 	    free_string(prgpstrShow[iShow]);\n  199  	    continue;\n  200  	}\n  ...\n  214  	add_buf(output,prgpstrShow[iShow]);\n  215  	add_buf(output,\"\\n\\r\");\n  216: 	free_string( prgpstrShow[iShow] );\n  217      }\n  218  \n  ...\n  883     }\n  884   \n  885:    free_string( ch->prompt );\n  886     ch->prompt = str_dup( buf );\n  887     sprintf(buf,\"Prompt set to %s\\n\\r\",ch->prompt );\n  ...\n 2380      }\n 2381  \n 2382:     free_string( ch->pcdata->title );\n 2383      ch->pcdata->title = str_dup( buf );\n 2384      return;\n ....\n 2443                      {\n 2444                          buf[len + 1] = '\\0';\n 2445: 			free_string(ch->description);\n 2446  			ch->description = str_dup(buf);\n 2447  			send_to_char( \"Your description is:\\n\\r\", ch );\n ....\n 2453              }\n 2454              buf[0] = '\\0';\n 2455: 	    free_string(ch->description);\n 2456  	    ch->description = str_dup(buf);\n 2457  	    send_to_char(\"Description cleared.\\n\\r\",ch);\n ....\n 2475  	strcat( buf, argument );\n 2476  	strcat( buf, \"\\n\\r\" );\n 2477: 	free_string( ch->description );\n 2478  	ch->description = str_dup( buf );\n 2479      }\n ....\n 2746      }\n 2747  \n 2748:     free_string( ch->pcdata->pwd );\n 2749      ch->pcdata->pwd = str_dup( pwdnew );\n 2750      save_char_obj( ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\act_obj.c:\n 2608  	{\n 2609  	    sprintf( buf, \"%s %s\", pet->name, arg );\n 2610: 	    free_string( pet->name );\n 2611  	    pet->name = str_dup( buf );\n 2612  	}\n ....\n 2614  	sprintf( buf, \"%sA neck tag says 'I belong to %s'.\\n\\r\",\n 2615  	    pet->description, ch->name );\n 2616: 	free_string( pet->description );\n 2617  	pet->description = str_dup( buf );\n 2618  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\act_wiz.c:\n  455  	}\n  456  	     \n  457: 	free_string( ch->pcdata->bamfin );\n  458  	ch->pcdata->bamfin = str_dup( argument );\n  459  \n  ...\n  485          }\n  486   \n  487:         free_string( ch->pcdata->bamfout );\n  488          ch->pcdata->bamfout = str_dup( argument );\n  489   \n  ...\n 2271      if (ch->prompt != NULL)\n 2272      {\n 2273: 	free_string(ch->prompt);\n 2274  	ch->prompt = NULL;\n 2275      }\n ....\n 3790  	    	return;\n 3791  	    }\n 3792: 	    free_string( victim->name );\n 3793  	    victim->name = str_dup( arg3 );\n 3794  	    return;\n ....\n 3797      	if ( !str_prefix( arg2, \"description\" ) )\n 3798      	{\n 3799:     	    free_string(victim->description);\n 3800      	    victim->description = str_dup(arg3);\n 3801      	    return;\n ....\n 3804      	if ( !str_prefix( arg2, \"short\" ) )\n 3805      	{\n 3806: 	    free_string( victim->short_descr );\n 3807  	    victim->short_descr = str_dup( arg3 );\n 3808  	    return;\n ....\n 3811      	if ( !str_prefix( arg2, \"long\" ) )\n 3812      	{\n 3813: 	    free_string( victim->long_descr );\n 3814  	    strcat(arg3,\"\\n\\r\");\n 3815  	    victim->long_descr = str_dup( arg3 );\n ....\n 3859          if ( !str_prefix( arg2, \"name\" ) )\n 3860      	{\n 3861: 	    free_string( obj->name );\n 3862  	    obj->name = str_dup( arg3 );\n 3863  	    return;\n ....\n 3866      	if ( !str_prefix( arg2, \"short\" ) )\n 3867      	{\n 3868: 	    free_string( obj->short_descr );\n 3869  	    obj->short_descr = str_dup( arg3 );\n 3870  	    return;\n ....\n 3873      	if ( !str_prefix( arg2, \"long\" ) )\n 3874      	{\n 3875: 	    free_string( obj->description );\n 3876  	    obj->description = str_dup( arg3 );\n 3877  	    return;\n ....\n 4407  \n 4408  	send_to_char(\"Prefix removed.\\r\\n\",ch);\n 4409: 	free_string(ch->prefix);\n 4410  	ch->prefix = str_dup(\"\");\n 4411  	return;\n ....\n 4415      {\n 4416  	sprintf(buf,\"Prefix changed to %s.\\r\\n\",argument);\n 4417: 	free_string(ch->prefix);\n 4418      }\n 4419      else\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\alias.c:\n  184  	if (!str_cmp(arg,rch->pcdata->alias[pos])) /* redefine an alias */\n  185  	{\n  186: 	    free_string(rch->pcdata->alias_sub[pos]);\n  187  	    rch->pcdata->alias_sub[pos] = str_dup(argument);\n  188  	    sprintf(buf,\"%s is now realiased to '%s'.\\n\\r\",arg,argument);\n  ...\n  246  	{\n  247  	    send_to_char(\"Alias removed.\\n\\r\",ch);\n  248: 	    free_string(rch->pcdata->alias[pos]);\n  249: 	    free_string(rch->pcdata->alias_sub[pos]);\n  250  	    rch->pcdata->alias[pos] = NULL;\n  251  	    rch->pcdata->alias_sub[pos] = NULL;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\comm.c:\n 1832  	}\n 1833  \n 1834: 	free_string( ch->pcdata->pwd );\n 1835  	ch->pcdata->pwd	= str_dup( pwdnew );\n 1836  	write_to_buffer( d, \"Please retype password: \", 0 );\n ....\n 2316  		if ( fConn == FALSE )\n 2317  		{\n 2318: 		free_string( d->character->pcdata->pwd );\n 2319  		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );\n 2320  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\fight.c:\n 1492  \n 1493      sprintf( buf, corpse->short_descr, name );\n 1494:     free_string( corpse->short_descr );\n 1495      corpse->short_descr = str_dup( buf );\n 1496  \n 1497      sprintf( buf, corpse->description, name );\n 1498:     free_string( corpse->description );\n 1499      corpse->description = str_dup( buf );\n 1500  \n ....\n 1636  \n 1637  	sprintf( buf, obj->short_descr, name );\n 1638: 	free_string( obj->short_descr );\n 1639  	obj->short_descr = str_dup( buf );\n 1640  \n 1641  	sprintf( buf, obj->description, name );\n 1642: 	free_string( obj->description );\n 1643  	obj->description = str_dup( buf );\n 1644  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\handler.c:\n 2228          obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );\n 2229          sprintf( buf, obj->short_descr, gold );\n 2230:         free_string( obj->short_descr );\n 2231          obj->short_descr        = str_dup( buf );\n 2232          obj->value[1]           = gold;\n ....\n 2238          obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );\n 2239          sprintf( buf, obj->short_descr, silver );\n 2240:         free_string( obj->short_descr );\n 2241          obj->short_descr        = str_dup( buf );\n 2242          obj->value[0]           = silver;\n ....\n 2249  	obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );\n 2250  	sprintf( buf, obj->short_descr, silver, gold );\n 2251: 	free_string( obj->short_descr );\n 2252  	obj->short_descr	= str_dup( buf );\n 2253  	obj->value[0]		= silver;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n113 matches across 17 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\alias.c:\n  184  	if (!str_cmp(arg,rch->pcdata->alias[pos])) /* redefine an alias */\n  185  	{\n  186: 	    free_string(rch->pcdata->alias_sub[pos]);\n  187  	    rch->pcdata->alias_sub[pos] = str_dup(argument);\n  188  	    sprintf(buf,\"%s is now realiased to '%s'.\\n\\r\",arg,argument);\n  ...\n  246  	{\n  247  	    send_to_char(\"Alias removed.\\n\\r\",ch);\n  248: 	    free_string(rch->pcdata->alias[pos]);\n  249: 	    free_string(rch->pcdata->alias_sub[pos]);\n  250  	    rch->pcdata->alias[pos] = NULL;\n  251  	    rch->pcdata->alias_sub[pos] = NULL;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\comm.c:\n 1832  	}\n 1833  \n 1834: 	free_string( ch->pcdata->pwd );\n 1835  	ch->pcdata->pwd	= str_dup( pwdnew );\n 1836  	write_to_buffer( d, \"Please retype password: \", 0 );\n ....\n 2316  		if ( fConn == FALSE )\n 2317  		{\n 2318: 		free_string( d->character->pcdata->pwd );\n 2319  		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );\n 2320  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\fight.c:\n 1492  \n 1493      sprintf( buf, corpse->short_descr, name );\n 1494:     free_string( corpse->short_descr );\n 1495      corpse->short_descr = str_dup( buf );\n 1496  \n 1497      sprintf( buf, corpse->description, name );\n 1498:     free_string( corpse->description );\n 1499      corpse->description = str_dup( buf );\n 1500  \n ....\n 1636  \n 1637  	sprintf( buf, obj->short_descr, name );\n 1638: 	free_string( obj->short_descr );\n 1639  	obj->short_descr = str_dup( buf );\n 1640  \n 1641  	sprintf( buf, obj->description, name );\n 1642: 	free_string( obj->description );\n 1643  	obj->description = str_dup( buf );\n 1644  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\handler.c:\n 2228          obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );\n 2229          sprintf( buf, obj->short_descr, gold );\n 2230:         free_string( obj->short_descr );\n 2231          obj->short_descr        = str_dup( buf );\n 2232          obj->value[1]           = gold;\n ....\n 2238          obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );\n 2239          sprintf( buf, obj->short_descr, silver );\n 2240:         free_string( obj->short_descr );\n 2241          obj->short_descr        = str_dup( buf );\n 2242          obj->value[0]           = silver;\n ....\n 2249  	obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );\n 2250  	sprintf( buf, obj->short_descr, silver, gold );\n 2251: 	free_string( obj->short_descr );\n 2252  	obj->short_descr	= str_dup( buf );\n 2253  	obj->value[0]		= silver;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n91 matches across 14 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\comm.c:\n 1832  	}\n 1833  \n 1834: 	free_string( ch->pcdata->pwd );\n 1835  	ch->pcdata->pwd	= str_dup( pwdnew );\n 1836  	write_to_buffer( d, \"Please retype password: \", 0 );\n ....\n 2316  		if ( fConn == FALSE )\n 2317  		{\n 2318: 		free_string( d->character->pcdata->pwd );\n 2319  		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );\n 2320  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\fight.c:\n 1492  \n 1493      sprintf( buf, corpse->short_descr, name );\n 1494:     free_string( corpse->short_descr );\n 1495      corpse->short_descr = str_dup( buf );\n 1496  \n 1497      sprintf( buf, corpse->description, name );\n 1498:     free_string( corpse->description );\n 1499      corpse->description = str_dup( buf );\n 1500  \n ....\n 1636  \n 1637  	sprintf( buf, obj->short_descr, name );\n 1638: 	free_string( obj->short_descr );\n 1639  	obj->short_descr = str_dup( buf );\n 1640  \n 1641  	sprintf( buf, obj->description, name );\n 1642: 	free_string( obj->description );\n 1643  	obj->description = str_dup( buf );\n 1644  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\handler.c:\n 2228          obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );\n 2229          sprintf( buf, obj->short_descr, gold );\n 2230:         free_string( obj->short_descr );\n 2231          obj->short_descr        = str_dup( buf );\n 2232          obj->value[1]           = gold;\n ....\n 2238          obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );\n 2239          sprintf( buf, obj->short_descr, silver );\n 2240:         free_string( obj->short_descr );\n 2241          obj->short_descr        = str_dup( buf );\n 2242          obj->value[0]           = silver;\n ....\n 2249  	obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );\n 2250  	sprintf( buf, obj->short_descr, silver, gold );\n 2251: 	free_string( obj->short_descr );\n 2252  	obj->short_descr	= str_dup( buf );\n 2253  	obj->value[0]		= silver;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n88 matches across 13 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\fight.c:\n 1492  \n 1493      sprintf( buf, corpse->short_descr, name );\n 1494:     free_string( corpse->short_descr );\n 1495      corpse->short_descr = str_dup( buf );\n 1496  \n 1497      sprintf( buf, corpse->description, name );\n 1498:     free_string( corpse->description );\n 1499      corpse->description = str_dup( buf );\n 1500  \n ....\n 1636  \n 1637  	sprintf( buf, obj->short_descr, name );\n 1638: 	free_string( obj->short_descr );\n 1639  	obj->short_descr = str_dup( buf );\n 1640  \n 1641  	sprintf( buf, obj->description, name );\n 1642: 	free_string( obj->description );\n 1643  	obj->description = str_dup( buf );\n 1644  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\handler.c:\n 2228          obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );\n 2229          sprintf( buf, obj->short_descr, gold );\n 2230:         free_string( obj->short_descr );\n 2231          obj->short_descr        = str_dup( buf );\n 2232          obj->value[1]           = gold;\n ....\n 2238          obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );\n 2239          sprintf( buf, obj->short_descr, silver );\n 2240:         free_string( obj->short_descr );\n 2241          obj->short_descr        = str_dup( buf );\n 2242          obj->value[0]           = silver;\n ....\n 2249  	obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );\n 2250  	sprintf( buf, obj->short_descr, silver, gold );\n 2251: 	free_string( obj->short_descr );\n 2252  	obj->short_descr	= str_dup( buf );\n 2253  	obj->value[0]		= silver;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n86 matches across 12 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\handler.c:\n 2228          obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );\n 2229          sprintf( buf, obj->short_descr, gold );\n 2230:         free_string( obj->short_descr );\n 2231          obj->short_descr        = str_dup( buf );\n 2232          obj->value[1]           = gold;\n ....\n 2238          obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );\n 2239          sprintf( buf, obj->short_descr, silver );\n 2240:         free_string( obj->short_descr );\n 2241          obj->short_descr        = str_dup( buf );\n 2242          obj->value[0]           = silver;\n ....\n 2249  	obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );\n 2250  	sprintf( buf, obj->short_descr, silver, gold );\n 2251: 	free_string( obj->short_descr );\n 2252  	obj->short_descr	= str_dup( buf );\n 2253  	obj->value[0]		= silver;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n82 matches across 11 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\hedit.c:\n  109  	}\n  110  \n  111: 	free_string(help->keyword);\n  112  	help->keyword = str_dup(argument);\n  113  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n79 matches across 10 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\magic.c:\n 1546  \n 1547  		sprintf( buf, \"%s water\", obj->name );\n 1548: 		free_string( obj->name );\n 1549  		obj->name = str_dup( buf );\n 1550  	}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\mem.c:\n  127  void free_area( AREA_DATA *pArea )\n  128  {\n  129:     free_string( pArea->name );\n  130:     free_string( pArea->file_name );\n  131:     free_string( pArea->builders );\n  132:     free_string( pArea->credits );\n  133  \n  134      pArea->next         =   area_free->next;\n  ...\n  170  void free_exit( EXIT_DATA *pExit )\n  171  {\n  172:     free_string( pExit->keyword );\n  173:     free_string( pExit->description );\n  174  \n  175      pExit->next         =   exit_free;\n  ...\n  226      RESET_DATA *pReset;\n  227  \n  228:     free_string( pRoom->name );\n  229:     free_string( pRoom->description );\n  230:     free_string( pRoom->owner );\n  231  \n  232      for ( door = 0; door < MAX_DIR; door++ )\n  ...\n  342      AFFECT_DATA *pAf;\n  343  \n  344:     free_string( pObj->name );\n  345:     free_string( pObj->short_descr );\n  346:     free_string( pObj->description );\n  347  \n  348      for ( pAf = pObj->affected; pAf; pAf = pAf->next )\n  ...\n  430  void free_mob_index( MOB_INDEX_DATA *pMob )\n  431  {\n  432:     free_string( pMob->player_name );\n  433:     free_string( pMob->short_descr );\n  434:     free_string( pMob->long_descr );\n  435:     free_string( pMob->description );\n  436      free_mprog( pMob->mprogs );\n  437  \n  ...\n  469  void free_mpcode(MPROG_CODE *pMcode)\n  470  {\n  471:     free_string(pMcode->code);\n  472      pMcode->next = mpcode_free;\n  473      mpcode_free  = pMcode;\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n78 matches across 9 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\note.c:\n  410         if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\\0' )\n  411         {\n  412: 	   free_string( pnote->to_list );\n  413  	   pnote->to_list = str_dup( to_new + 1 );\n  414  	   return;\n  ...\n  794  	add_buf(buffer,argument);\n  795  	add_buf(buffer,\"\\n\\r\");\n  796: 	free_string( ch->pnote->text );\n  797  	ch->pnote->text = str_dup( buf_string(buffer) );\n  798  	free_buf(buffer);\n  ...\n  835  		{\n  836  		    buf[len + 1] = '\\0';\n  837: 		    free_string(ch->pnote->text);\n  838  		    ch->pnote->text = str_dup(buf);\n  839  		    return;\n  ...\n  842  	}\n  843  	buf[0] = '\\0';\n  844: 	free_string(ch->pnote->text);\n  845  	ch->pnote->text = str_dup(buf);\n  846  	return;\n  ...\n  857          }\n  858  \n  859: 	free_string( ch->pnote->subject );\n  860  	ch->pnote->subject = str_dup( argument );\n  861  	send_to_char( \"Ok.\\n\\r\", ch );\n  ...\n  872              return;\n  873          }\n  874: 	free_string( ch->pnote->to_list );\n  875  	ch->pnote->to_list = str_dup( argument );\n  876  	send_to_char( \"Ok.\\n\\r\", ch );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n60 matches across 7 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\olc_act.c:\n  694      }\n  695  \n  696:     free_string( pArea->name );\n  697      pArea->name = str_dup( argument );\n  698  \n  ...\n  713      }\n  714  \n  715:     free_string( pArea->credits );\n  716      pArea->credits = str_dup( argument );\n  717  \n  ...\n  759      }    \n  760  \n  761:     free_string( pArea->file_name );\n  762      strcat( file, \".are\" );\n  763      pArea->file_name = str_dup( file );\n  ...\n  889  	if ( pArea->builders[0] == '\\0' )\n  890  	{\n  891: 	    free_string( pArea->builders );\n  892  	    pArea->builders = str_dup( \"None\" );\n  893  	}\n  ...\n  910  	}\n  911  	strcat( buf, name );\n  912: 	free_string( pArea->builders );\n  913  	pArea->builders = string_proper( str_dup( buf ) );\n  914  \n  ...\n 1485  	   }\n 1486  \n 1487: 	free_string( pRoom->exit[door]->keyword );\n 1488  \n 1489  	if (str_cmp(arg,\"none\"))\n ....\n 1779      }\n 1780  \n 1781:     free_string( pRoom->name );\n 1782      pRoom->name = str_dup( argument );\n 1783  \n ....\n 2980      }\n 2981  \n 2982:     free_string( pObj->name );\n 2983      pObj->name = str_dup( argument );\n 2984  \n ....\n 3001      }\n 3002  \n 3003:     free_string( pObj->short_descr );\n 3004      pObj->short_descr = str_dup( argument );\n 3005      pObj->short_descr[0] = LOWER( pObj->short_descr[0] );\n ....\n 3023      }\n 3024          \n 3025:     free_string( pObj->description );\n 3026      pObj->description = str_dup( argument );\n 3027      pObj->description[0] = UPPER( pObj->description[0] );\n ....\n 3437      }\n 3438  \n 3439:     free_string( pObj->material );\n 3440      pObj->material = str_dup( argument );\n 3441  \n ....\n 3858      }\n 3859  \n 3860:     free_string( pMob->long_descr );\n 3861      strcat( argument, \"\\n\\r\" );\n 3862      pMob->long_descr = str_dup( argument );\n ....\n 3881      }\n 3882  \n 3883:     free_string( pMob->short_descr );\n 3884      pMob->short_descr = str_dup( argument );\n 3885  \n ....\n 3902      }\n 3903  \n 3904:     free_string( pMob->player_name );\n 3905      pMob->player_name = str_dup( argument );\n 3906  \n ....\n 4340      }\n 4341  \n 4342:     free_string( pMob->material );\n 4343      pMob->material = str_dup( argument );\n 4344  \n ....\n 4796      }\n 4797  \n 4798:     free_string( pRoom->owner );\n 4799      if (!str_cmp(argument, \"none\"))\n 4800      	pRoom->owner = str_dup(\"\");\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n54 matches across 6 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\recycle.c:\n   62  	return;\n   63  \n   64: 	free_string( note->text    );\n   65: 	free_string( note->subject );\n   66: 	free_string( note->to_list );\n   67: 	free_string( note->date    );\n   68: 	free_string( note->sender  );\n   69  	INVALIDATE(note);\n   70  \n   ..\n  101  	return;\n  102  \n  103: 	free_string(ban->name);\n  104  	INVALIDATE(ban);\n  105  \n  ...\n  195  	return;\n  196  \n  197: 	free_string(ed->keyword);\n  198: 	free_string(ed->description);\n  199  	INVALIDATE(ed);\n  200  	\n  ...\n  280  	 obj->extra_descr = NULL;\n  281     \n  282: 	free_string( obj->name        );\n  283: 	free_string( obj->description );\n  284: 	free_string( obj->short_descr );\n  285: 	free_string( obj->owner     );\n  286  	INVALIDATE(obj);\n  287  \n  ...\n  362  	}\n  363  \n  364: 	free_string(ch->name);\n  365: 	free_string(ch->short_descr);\n  366: 	free_string(ch->long_descr);\n  367: 	free_string(ch->description);\n  368: 	free_string(ch->prompt);\n  369: 	free_string(ch->prefix);\n  370  	free_note  (ch->pnote);\n  371  	free_pcdata(ch->pcdata);\n  ...\n  417  	return;\n  418  \n  419: 	free_string(pcdata->pwd);\n  420: 	free_string(pcdata->bamfin);\n  421: 	free_string(pcdata->bamfout);\n  422: 	free_string(pcdata->title);\n  423  	free_buf(pcdata->buffer);\n  424  	\n  425  	for (alias = 0; alias < MAX_ALIAS; alias++)\n  426  	{\n  427: 	free_string(pcdata->alias[alias]);\n  428: 	free_string(pcdata->alias_sub[alias]);\n  429  	}\n  430  	INVALIDATE(pcdata);\n  ...\n  708  void free_help(HELP_DATA *help)\n  709  {\n  710: 	free_string(help->keyword);\n  711: 	free_string(help->text);\n  712  	help->next = help_free;\n  713  	help_free = help;\n  ...\n  742  		return;\n  743  \n  744: 	free_string(wiz->name);\n  745  	INVALIDATE(wiz);\n  746  \n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n38 matches across 5 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\save.c:\n  725  				if ( !str_cmp( word, literal ) )	\\\n  726  				{					\\\n  727: 				    free_string(field);			\\\n  728  				    field  = value;			\\\n  729  				    fMatch = TRUE;			\\\n  ...\n 1098  		{\n 1099  		    sprintf( buf, \" %s\", ch->pcdata->title );\n 1100: 		    free_string( ch->pcdata->title );\n 1101  		    ch->pcdata->title = str_dup( buf );\n 1102  		}\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n11 matches across 4 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\string.c:\n  106          strcat( xbuf, new );\n  107          strcat( xbuf, &orig[i+strlen( old )] );\n  108:         free_string( orig );\n  109      }\n  110  \n  ...\n  143          {\n  144              send_to_char( \"String cleared.\\n\\r\", ch );\n  145: 	    free_string(*ch->desc->pString);\n  146  	    *ch->desc->pString = str_dup( \"\" );\n  147              return;\n  ...\n  270      strcat( buf, argument );\n  271      strcat( buf, \"\\n\\r\" );\n  272:     free_string( *ch->desc->pString );\n  273      *ch->desc->pString = str_dup( buf );\n  274      return;\n  ...\n  430      strcat(xbuf,\"\\n\\r\");\n  431  \n  432:   free_string(oldstring);\n  433    return(str_dup(xbuf));\n  434  }\n  ...\n  519      }\n  520  \n  521:     free_string( argument );\n  522      return str_dup( buf );\n  523  }\n  ...\n  581  	buf[tmp] = '\\0';\n  582  \n  583: 	free_string(string);\n  584  	return str_dup(buf);\n  585  }\n  ...\n  621  	}\n  622  \n  623: 	free_string(string);\n  624  	return str_dup(buf);\n  625  }\n\n9 matches across 3 files\n\n\nSearching 55 files for \"free_string\"\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\db.c:\n 3128   * Read-only shared strings are not touched.\n 3129   */\n 3130: void free_string( char *pstr )\n 3131  {\n 3132  	if ( pstr == NULL\n\nC:\\Users\\valpo\\Documents\\GitHub\\dungeonworld\\src\\merc.h:\n 2248  void *	alloc_perm	args( ( int sMem ) );\n 2249  void	free_mem	args( ( void *pMem, int sMem ) );\n 2250: void	free_string	args( ( char *pstr ) );\n 2251  int	number_fuzzy	args( ( int number ) );\n 2252  int	number_range	args( ( int from, int to ) );\n\n2 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 97709,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "/***************************************************************************\n *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *\n *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *\n *                                                                         *\n *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *\n *  Chastain, Michael Quan, and Mitchell Tse.                              *\n *                                                                         *\n *  In order to use any part of this Merc Diku Mud, you must comply with   *\n *  both the original Diku license in 'license.doc' as well the Merc       *\n *  license in 'license.txt'.  In particular, you may not remove either of *\n *  these copyright notices.                                               *\n *                                                                         *\n *  Much time and thought has gone into this software and you are          *\n *  benefitting.  We hope that you share your changes too.  What goes      *\n *  around, comes around.                                                  *\n ***************************************************************************/\n\n/***************************************************************************\n*	ROM 2.4 is copyright 1993-1998 Russ Taylor			   *\n*	ROM has been brought to you by the ROM consortium		   *\n*	    Russ Taylor (rtaylor@hypercube.org)				   *\n*	    Gabrielle Taylor (gtaylor@hypercube.org)			   *\n*	    Brian Moore (zump@rom.org)					   *\n*	By using this code, you have agreed to follow the terms of the	   *\n*	ROM license, in the file Rom24/doc/rom.license			   *\n***************************************************************************/\n\n#include <ctype.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n\n\n#if defined(macintosh)\n#include <types.h>\n#else\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#endif\n\n#include \"merc.h\"\n#include \"db.h\"\n#include \"recycle.h\"\n#include \"music.h\"\n#include \"tables.h\"\n#include \"lookup.h\"\n#include \"olc.h\"\n\nbool logFail = FALSE;           // this can be turned into a global value, it doesn't really need to be true\n                                // however if you want to log which pointers are NULL when cleared\n                                // then be my guest and change this value to true.\n\n#if !defined(macintosh)\nextern	int	_filbuf		args( (FILE *) );\n#endif\n\n#if !defined(OLD_RAND)\n#if !defined(linux)\nlong random();\n#endif\nvoid srandom(unsigned int);\nint getpid();\ntime_t time(time_t *tloc);\n#endif\n\n\n/* externals for counting purposes */\nextern	OBJ_DATA	*obj_free;\nextern	CHAR_DATA	*char_free;\nextern  DESCRIPTOR_DATA *descriptor_free;\nextern	PC_DATA		*pcdata_free;\nextern  AFFECT_DATA	*affect_free;\n\n/*\n * Globals.\n */\nHELP_DATA *		help_first;\nHELP_DATA *		help_last;\n\nHELP_AREA *		had_list;\n\nSHOP_DATA *		shop_first;\nSHOP_DATA *		shop_last;\n\nNOTE_DATA *		note_free;\n\nMPROG_CODE *		mprog_list;\n\nchar			bug_buf		[2*MAX_INPUT_LENGTH];\nCHAR_DATA *		char_list;\nchar *			help_greeting;\nchar			log_buf		[2*MAX_INPUT_LENGTH];\nKILL_DATA		kill_table	[MAX_LEVEL];\nNOTE_DATA *		note_list;\nOBJ_DATA *		object_list;\nTIME_INFO_DATA		time_info;\nWEATHER_DATA		weather_info;\n\nsh_int			gsn_backstab;\nsh_int			gsn_dodge;\nsh_int			gsn_envenom;\nsh_int			gsn_hide;\nsh_int			gsn_peek;\nsh_int			gsn_pick_lock;\nsh_int			gsn_sneak;\nsh_int			gsn_steal;\n\nsh_int			gsn_disarm;\nsh_int			gsn_enhanced_damage;\nsh_int			gsn_kick;\nsh_int			gsn_parry;\nsh_int			gsn_rescue;\nsh_int			gsn_second_attack;\nsh_int			gsn_third_attack;\n\nsh_int			gsn_blindness;\nsh_int			gsn_charm_person;\nsh_int			gsn_curse;\nsh_int			gsn_invis;\nsh_int			gsn_mass_invis;\nsh_int			gsn_poison;\nsh_int			gsn_plague;\nsh_int			gsn_sleep;\nsh_int			gsn_sanctuary;\nsh_int			gsn_fly;\n/* new gsns */\n\nsh_int  		gsn_axe;\nsh_int  		gsn_dagger;\nsh_int  		gsn_flail;\nsh_int  		gsn_mace;\nsh_int  		gsn_polearm;\nsh_int			gsn_shield_block;\nsh_int  		gsn_spear;\nsh_int  		gsn_sword;\nsh_int  		gsn_whip;\n \nsh_int  		gsn_bash;\nsh_int  		gsn_berserk;\nsh_int  		gsn_dirt;\nsh_int  		gsn_hand_to_hand;\nsh_int  		gsn_trip;\n \nsh_int  		gsn_fast_healing;\nsh_int  		gsn_haggle;\nsh_int  		gsn_lore;\nsh_int  		gsn_meditation;\n \nsh_int  		gsn_scrolls;\nsh_int  		gsn_staves;\nsh_int  		gsn_wands;\nsh_int  		gsn_recall;\n\n\n\n/*\n * Locals.\n */\nMOB_INDEX_DATA *	mob_index_hash		[MAX_KEY_HASH];\nOBJ_INDEX_DATA *	obj_index_hash		[MAX_KEY_HASH];\nROOM_INDEX_DATA *	room_index_hash		[MAX_KEY_HASH];\nchar *			string_hash		[MAX_KEY_HASH];\n\nAREA_DATA *		area_first;\nAREA_DATA *		area_last;\nAREA_DATA *		current_area;\n\nchar *			string_space;\nchar *			top_string;\nchar			str_empty	[1];\n\nint			top_affect;\nint			top_area;\nint			top_ed;\nint			top_exit;\nint			top_help;\nint			top_mob_index;\nint			top_obj_index;\nint			top_reset;\nint			top_room;\nint			top_shop;\nint                     top_vnum_room;		/* OLC */\nint                     top_vnum_mob;		/* OLC */\nint                     top_vnum_obj;		/* OLC */\nint			top_mprog_index;	/* OLC */\nint 			mobile_count = 0;\nint			newmobs = 0;\nint			newobjs = 0;\n\n\n/*\n * Memory management.\n * Increase MAX_STRING if you have too.\n * Tune the others only if you understand what you're doing.\n */\n#define			MAX_STRING	1413120\n#define			MAX_PERM_BLOCK	131072\n#define			MAX_MEM_LIST	11\n\nvoid *			rgFreeList	[MAX_MEM_LIST];\nconst int		rgSizeList	[MAX_MEM_LIST]	=\n{\n	16, 32, 64, 128, 256, 1024, 2048, 4096, 8192, 16384, 32768-64\n};\n\nint			nAllocString;\nint			sAllocString;\nint			nAllocPerm;\nint			sAllocPerm;\n\n\n\n/*\n * Semi-locals.\n */\nbool			fBootDb;\nFILE *			fpArea;\nchar			strArea[MAX_INPUT_LENGTH];\n\n\n\n/*\n * Local booting procedures.\n*/\nvoid    init_mm         args( ( void ) );\nvoid	load_area	args( ( FILE *fp ) );\nvoid    new_load_area   args( ( FILE *fp ) );   /* OLC */\nvoid	load_helps	args( ( FILE *fp, char *fname ) );\nvoid	load_old_mob	args( ( FILE *fp ) );\nvoid 	load_mobiles	args( ( FILE *fp ) );\nvoid	load_old_obj	args( ( FILE *fp ) );\nvoid 	load_objects	args( ( FILE *fp ) );\nvoid	load_resets	args( ( FILE *fp ) );\nvoid	load_rooms	args( ( FILE *fp ) );\nvoid	load_shops	args( ( FILE *fp ) );\nvoid 	load_socials	args( ( FILE *fp ) );\nvoid	load_specials	args( ( FILE *fp ) );\nvoid	load_notes	args( ( void ) );\nvoid	load_bans	args( ( void ) );\nvoid	load_mobprogs	args( ( FILE *fp ) );\nvoid	load_wizlist args( ( void ) );\n\nvoid	fix_exits	args( ( void ) );\nvoid    fix_mobprogs	args( ( void ) );\n\nvoid	reset_area	args( ( AREA_DATA * pArea ) );\n\n/*\n * Big mama top level function.\n */\nvoid boot_db( void )\n{\n\n	/*\n	 * Init some data space stuff.\n	 */\n	{\n	if ( ( string_space = calloc( 1, MAX_STRING ) ) == NULL )\n	{\n		bug( \"Boot_db: can't alloc %d string space.\", MAX_STRING );\n		exit( 1 );\n	}\n	top_string	= string_space;\n	fBootDb		= TRUE;\n	}\n\n	/*\n	 * Init random number generator.\n	 */\n	{\n		init_mm( );\n	}\n\n	/*\n	 * Set time and weather.\n	 */\n	{\n	long lhour, lday, lmonth;\n\n	lhour		= (current_time - 650336715)\n			/ (PULSE_TICK / PULSE_PER_SECOND);\n	time_info.hour	= lhour  % 24;\n	lday		= lhour  / 24;\n	time_info.day	= lday   % 35;\n	lmonth		= lday   / 35;\n	time_info.month	= lmonth % 17;\n	time_info.year	= lmonth / 17;\n\n		 if ( time_info.hour <  5 ) weather_info.sunlight = SUN_DARK;\n	else if ( time_info.hour <  6 ) weather_info.sunlight = SUN_RISE;\n	else if ( time_info.hour < 19 ) weather_info.sunlight = SUN_LIGHT;\n	else if ( time_info.hour < 20 ) weather_info.sunlight = SUN_SET;\n	else                            weather_info.sunlight = SUN_DARK;\n\n	weather_info.change	= 0;\n	weather_info.mmhg	= 960;\n	if ( time_info.month >= 7 && time_info.month <=12 )\n		weather_info.mmhg += number_range( 1, 50 );\n	else\n		weather_info.mmhg += number_range( 1, 80 );\n\n		 if ( weather_info.mmhg <=  980 ) weather_info.sky = SKY_LIGHTNING;\n	else if ( weather_info.mmhg <= 1000 ) weather_info.sky = SKY_RAINING;\n	else if ( weather_info.mmhg <= 1020 ) weather_info.sky = SKY_CLOUDY;\n	else                                  weather_info.sky = SKY_CLOUDLESS;\n\n	}\n\n	/*\n	 * Assign gsn's for skills which have them.\n	 */\n	{\n	int sn;\n\n	for ( sn = 0; sn < MAX_SKILL; sn++ )\n	{\n		if ( skill_table[sn].pgsn != NULL )\n		*skill_table[sn].pgsn = sn;\n	}\n	}\n\n	/*\n	 * Read in all the area files.\n	 */\n	{\n	FILE *fpList;\n\n	if ( ( fpList = fopen( AREA_LIST, \"r\" ) ) == NULL )\n	{\n		perror( AREA_LIST );\n		exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n		strcpy( strArea, fread_word( fpList ) );\n		if ( strArea[0] == '$' )\n		break;\n\n		if ( strArea[0] == '-' )\n		{\n		fpArea = stdin;\n		}\n		else\n		{\n		if ( ( fpArea = fopen( strArea, \"r\" ) ) == NULL )\n		{\n			perror( strArea );\n			exit( 1 );\n		}\n		}\n\n		current_area = NULL;\n\n		for ( ; ; )\n		{\n		char *word;\n\n		if ( fread_letter( fpArea ) != '#' )\n		{\n			bug( \"Boot_db: # not found.\", 0 );\n			exit( 1 );\n		}\n\n		word = fread_word( fpArea );\n\n			 if ( word[0] == '$'               )                 break;\n		else if ( !str_cmp( word, \"AREA\"     ) ) load_area    (fpArea);\n  /* OLC */     else if ( !str_cmp( word, \"AREADATA\" ) ) new_load_area(fpArea);\n		else if ( !str_cmp( word, \"HELPS\"    ) ) load_helps   (fpArea, strArea);\n		else if ( !str_cmp( word, \"MOBOLD\"   ) ) load_old_mob (fpArea);\n		else if ( !str_cmp( word, \"MOBILES\"  ) ) load_mobiles (fpArea);\n		else if ( !str_cmp( word, \"MOBPROGS\" ) ) load_mobprogs(fpArea);\n		else if ( !str_cmp( word, \"OBJOLD\"   ) ) load_old_obj (fpArea);\n		else if ( !str_cmp( word, \"OBJECTS\"  ) ) load_objects (fpArea);\n		else if ( !str_cmp( word, \"RESETS\"   ) ) load_resets  (fpArea);\n		else if ( !str_cmp( word, \"ROOMS\"    ) ) load_rooms   (fpArea);\n		else if ( !str_cmp( word, \"SHOPS\"    ) ) load_shops   (fpArea);\n		else if ( !str_cmp( word, \"SOCIALS\"  ) ) load_socials (fpArea);\n		else if ( !str_cmp( word, \"SPECIALS\" ) ) load_specials(fpArea);\n		else\n		{\n			bug( \"Boot_db: bad section name.\", 0 );\n			exit( 1 );\n		}\n		}\n\n		if ( fpArea != stdin )\n		fclose( fpArea );\n		fpArea = NULL;\n	}\n	fclose( fpList );\n	}\n\n	/*\n	 * Fix up exits.\n	 * Declare db booting over.\n	 * Reset all areas once.\n	 * Load up the songs, notes and ban files.\n	 */\n	{\n	fix_exits( );\n	fix_mobprogs( );\n	fBootDb	= FALSE;\n		convert_objects( );           /* ROM OLC */\n	area_update( );\n	load_notes( );\n	load_bans();\n	load_songs();\n	load_wizlist();\n	}\n\n	return;\n}\n\n\n\n/*\n * Snarf an 'area' header line.\n */\nvoid load_area( FILE *fp )\n{\n	AREA_DATA *pArea;\n\n	pArea		= alloc_perm( sizeof(*pArea) );\n	pArea->file_name	= fread_string(fp);\n\n	pArea->area_flags   = AREA_LOADING;         /* OLC */\n	pArea->security     = 9;                    /* OLC */ /* 9 -- Hugin */\n	pArea->builders     = str_dup( \"None\" );    /* OLC */\n	pArea->vnum         = top_area;             /* OLC */\n\n	pArea->name		= fread_string( fp );\n	pArea->credits	= fread_string( fp );\n	pArea->min_vnum	= fread_number(fp);\n	pArea->max_vnum	= fread_number(fp);\n	pArea->age		= 15;\n	pArea->nplayer	= 0;\n	pArea->empty	= FALSE;\n\n	if ( !area_first )\n	area_first = pArea;\n	if ( area_last )\n	{\n	area_last->next = pArea;\n		REMOVE_BIT(area_last->area_flags, AREA_LOADING);        /* OLC */\n	}\n	area_last		= pArea;\n	pArea->next		= NULL;\n	current_area	= pArea;\n\n	top_area++;\n	return;\n}\n\n/*\n * OLC\n * Use these macros to load any new area formats that you choose to\n * support on your MUD.  See the new_load_area format below for\n * a short example.\n */\n#if defined(KEY)\n#undef KEY\n#endif\n\n#define KEY( literal, field, value )                \\\n				if ( !str_cmp( word, literal ) )    \\\n				{                                   \\\n					field  = value;                 \\\n					fMatch = TRUE;                  \\\n					break;                          \\\n								}\n\n#define SKEY( string, field )                       \\\n				if ( !str_cmp( word, string ) )     \\\n				{                                   \\\n					PURGE_DATA( field );           \\\n					field = fread_string( fp );     \\\n					fMatch = TRUE;                  \\\n					break;                          \\\n								}\n\n\n\n/* OLC\n * Snarf an 'area' header line.   Check this format.  MUCH better.  Add fields\n * too.\n *\n * #AREAFILE\n * Name   { All } Locke    Newbie School~\n * Repop  A teacher pops in the room and says, 'Repop coming!'~\n * Recall 3001\n * End\n */\nvoid new_load_area( FILE *fp )\n{\n	AREA_DATA *pArea;\n	char      *word;\n	bool      fMatch;\n\n	pArea               = alloc_perm( sizeof(*pArea) );\n	pArea->age          = 15;\n	pArea->nplayer      = 0;\n	pArea->file_name     = str_dup( strArea );\n	pArea->vnum         = top_area;\n	pArea->name         = str_dup( \"New Area\" );\n	pArea->builders     = str_dup( \"\" );\n	pArea->security     = 9;                    /* 9 -- Hugin */\n	pArea->min_vnum        = 0;\n	pArea->max_vnum        = 0;\n	pArea->area_flags   = 0;\n/*  pArea->recall       = ROOM_VNUM_TEMPLE;        ROM OLC */\n\n	for ( ; ; )\n	{\n	   word   = feof( fp ) ? \"End\" : fread_word( fp );\n	   fMatch = FALSE;\n\n	   switch ( UPPER(word[0]) )\n	   {\n		   case 'N':\n			SKEY( \"Name\", pArea->name );\n			break;\n		   case 'S':\n			 KEY( \"Security\", pArea->security, fread_number( fp ) );\n			break;\n		   case 'V':\n			if ( !str_cmp( word, \"VNUMs\" ) )\n			{\n				pArea->min_vnum = fread_number( fp );\n				pArea->max_vnum = fread_number( fp );\n			}\n			break;\n		   case 'E':\n			 if ( !str_cmp( word, \"End\" ) )\n			 {\n				 fMatch = TRUE;\n				 if ( area_first == NULL )\n					area_first = pArea;\n				 if ( area_last  != NULL )\n					area_last->next = pArea;\n				 area_last	= pArea;\n				 pArea->next	= NULL;\n		 current_area	= pArea;\n				 top_area++;\n\n				 return;\n			}\n			break;\n		   case 'B':\n			SKEY( \"Builders\", pArea->builders );\n			break;\n	   case 'C':\n		SKEY( \"Credits\", pArea->credits );\n		break;\n		}\n	}\n}\n\n/*\n * Sets vnum range for area using OLC protection features.\n */\nvoid assign_area_vnum( int vnum )\n{\n	if ( area_last->min_vnum == 0 || area_last->max_vnum == 0 )\n		area_last->min_vnum = area_last->max_vnum = vnum;\n	if ( vnum != URANGE( area_last->min_vnum, vnum, area_last->max_vnum ) )\n	{\n		if ( vnum < area_last->min_vnum )\n			area_last->min_vnum = vnum;\n		else\n			area_last->max_vnum = vnum;\n	}\n	return;\n}\n\n/*\n * Snarf a help section.\n */\nvoid load_helps( FILE *fp, char *fname )\n{\n	HELP_DATA *pHelp;\n	int level;\n	char *keyword;\n\n	for ( ; ; )\n	{\n	HELP_AREA * had;\n\n	level		= fread_number( fp );\n	keyword		= fread_string( fp );\n\n	if ( keyword[0] == '$' )\n		break;\n\n	if ( !had_list )\n	{\n		had			= new_had ();\n		had->filename		= str_dup( fname );\n		had->area		= current_area;\n		if ( current_area )\n			current_area->helps	= had;\n		had_list		= had;\n	}\n	else\n	if ( str_cmp( fname, had_list->filename ) )\n	{\n		had			= new_had ();\n		had->filename		= str_dup( fname );\n		had->area		= current_area;\n		if ( current_area )\n			current_area->helps	= had;\n		had->next		= had_list;\n		had_list		= had;\n	}\n	else\n		had			= had_list;\n\n	pHelp		= new_help( );\n	pHelp->level	= level;\n	pHelp->keyword	= keyword;\n	pHelp->text	= fread_string( fp );\n\n	if ( !str_cmp( pHelp->keyword, \"greeting\" ) )\n		help_greeting = pHelp->text;\n\n	if ( help_first == NULL )\n		help_first = pHelp;\n	if ( help_last  != NULL )\n		help_last->next = pHelp;\n\n	help_last		= pHelp;\n	pHelp->next		= NULL;\n\n	if ( !had->first )\n		had->first	= pHelp;\n	if ( !had->last )\n		had->last	= pHelp;\n\n	had->last->next_area	= pHelp;\n	had->last		= pHelp;\n	pHelp->next_area	= NULL;\n\n	top_help++;\n	}\n\n	return;\n}\n\n\n\n/*\n * Snarf a mob section.  old style \n */\nvoid load_old_mob( FILE *fp )\n{\n	MOB_INDEX_DATA *pMobIndex;\n	/* for race updating */\n	int race;\n	char name[MAX_STRING_LENGTH];\n\n	if ( !area_last )   /* OLC */\n	{\n		bug( \"Load_mobiles: no #AREA seen yet.\", 0 );\n		exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n	sh_int vnum;\n	char letter;\n	int iHash;\n\n	letter				= fread_letter( fp );\n	if ( letter != '#' )\n	{\n		bug( \"Load_mobiles: # not found.\", 0 );\n		exit( 1 );\n	}\n\n	vnum				= fread_number( fp );\n	if ( vnum == 0 )\n		break;\n\n	fBootDb = FALSE;\n	if ( get_mob_index( vnum ) != NULL )\n	{\n		bug( \"Load_mobiles: vnum %d duplicated.\", vnum );\n		exit( 1 );\n	}\n	fBootDb = TRUE;\n\n	pMobIndex			= alloc_perm( sizeof(*pMobIndex) );\n	pMobIndex->vnum			= vnum;\n		pMobIndex->area                 = area_last;               /* OLC */\n	pMobIndex->new_format		= FALSE;\n	pMobIndex->player_name		= fread_string( fp );\n	pMobIndex->short_descr		= fread_string( fp );\n	pMobIndex->long_descr		= fread_string( fp );\n	pMobIndex->description		= fread_string( fp );\n\n	pMobIndex->long_descr[0]	= UPPER(pMobIndex->long_descr[0]);\n	pMobIndex->description[0]	= UPPER(pMobIndex->description[0]);\n\n	pMobIndex->act			= fread_flag( fp ) | ACT_IS_NPC;\n	pMobIndex->affected_by		= fread_flag( fp );\n	pMobIndex->pShop		= NULL;\n	pMobIndex->alignment		= fread_number( fp );\n	letter				= fread_letter( fp );\n	pMobIndex->level		= fread_number( fp );\n\n	/*\n	 * The unused stuff is for imps who want to use the old-style\n	 * stats-in-files method.\n	 */\n					  fread_number( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n	/* 'd'		*/		  fread_letter( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n	/* '+'		*/		  fread_letter( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n	/* 'd'		*/		  fread_letter( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n	/* '+'		*/		  fread_letter( fp );	/* Unused */\n					  fread_number( fp );	/* Unused */\n		pMobIndex->wealth               = fread_number( fp )/20;	\n	/* xp can't be used! */		  fread_number( fp );	/* Unused */\n	pMobIndex->start_pos		= fread_number( fp );	/* Unused */\n	pMobIndex->default_pos		= fread_number( fp );	/* Unused */\n\n	if (pMobIndex->start_pos < POS_SLEEPING)\n		pMobIndex->start_pos = POS_STANDING;\n	if (pMobIndex->default_pos < POS_SLEEPING)\n		pMobIndex->default_pos = POS_STANDING;\n\n	/*\n	 * Back to meaningful values.\n	 */\n	pMobIndex->sex			= fread_number( fp );\n\n		/* compute the race BS */\n	one_argument(pMobIndex->player_name,name);\n \n	if (name[0] == '\\0' || (race =  race_lookup(name)) == 0)\n	{\n			/* fill in with blanks */\n			pMobIndex->race = race_lookup(\"human\");\n			pMobIndex->off_flags = OFF_DODGE|OFF_DISARM|OFF_TRIP|ASSIST_VNUM;\n			pMobIndex->imm_flags = 0;\n			pMobIndex->res_flags = 0;\n			pMobIndex->vuln_flags = 0;\n			pMobIndex->form = FORM_EDIBLE|FORM_SENTIENT|FORM_HUMANOID|FORM_MAMMAL;\n			pMobIndex->parts = PART_HEAD|PART_ARMS|PART_LEGS|PART_HEART|\n							   PART_BRAINS|PART_GUTS;\n		}\n		else\n		{\n			pMobIndex->race = race;\n			pMobIndex->off_flags = OFF_DODGE|OFF_DISARM|OFF_TRIP|ASSIST_RACE|\n								   race_table[race].off;\n			pMobIndex->imm_flags = race_table[race].imm;\n			pMobIndex->res_flags = race_table[race].res;\n			pMobIndex->vuln_flags = race_table[race].vuln;\n			pMobIndex->form = race_table[race].form;\n			pMobIndex->parts = race_table[race].parts;\n		}\n\n	if ( letter != 'S' )\n	{\n		bug( \"Load_mobiles: vnum %d non-S.\", vnum );\n		exit( 1 );\n	}\n\n	convert_mobile( pMobIndex );                           /* ROM OLC */\n\n	iHash			= vnum % MAX_KEY_HASH;\n	pMobIndex->next		= mob_index_hash[iHash];\n	mob_index_hash[iHash]	= pMobIndex;\n	top_mob_index++;\n		top_vnum_mob = top_vnum_mob < vnum ? vnum : top_vnum_mob;  /* OLC */\n		assign_area_vnum( vnum );                                  /* OLC */\n	kill_table[URANGE(0, pMobIndex->level, MAX_LEVEL-1)].number++;\n	}\n\n	return;\n}\n\n/*\n * Snarf an obj section.  old style \n */\nvoid load_old_obj( FILE *fp )\n{\n	OBJ_INDEX_DATA *pObjIndex;\n\n	if ( !area_last )   /* OLC */\n	{\n		bug( \"Load_objects: no #AREA seen yet.\", 0 );\n		exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n	sh_int vnum;\n	char letter;\n	int iHash;\n\n	letter				= fread_letter( fp );\n	if ( letter != '#' )\n	{\n		bug( \"Load_objects: # not found.\", 0 );\n		exit( 1 );\n	}\n\n	vnum				= fread_number( fp );\n	if ( vnum == 0 )\n		break;\n\n	fBootDb = FALSE;\n	if ( get_obj_index( vnum ) != NULL )\n	{\n		bug( \"Load_objects: vnum %d duplicated.\", vnum );\n		exit( 1 );\n	}\n	fBootDb = TRUE;\n\n	pObjIndex			= alloc_perm( sizeof(*pObjIndex) );\n	pObjIndex->vnum			= vnum;\n		pObjIndex->area                 = area_last;            /* OLC */\n	pObjIndex->new_format		= FALSE;\n	pObjIndex->reset_num	 	= 0;\n	pObjIndex->name			= fread_string( fp );\n	pObjIndex->short_descr		= fread_string( fp );\n	pObjIndex->description		= fread_string( fp );\n	/* Action description */	  fread_string( fp );\n\n	pObjIndex->short_descr[0]	= LOWER(pObjIndex->short_descr[0]);\n	pObjIndex->description[0]	= UPPER(pObjIndex->description[0]);\n	pObjIndex->material		= NULL;\n\n	pObjIndex->item_type		= fread_number( fp );\n	pObjIndex->extra_flags		= fread_flag( fp );\n	pObjIndex->wear_flags		= fread_flag( fp );\n	pObjIndex->value[0]		= fread_number( fp );\n	pObjIndex->value[1]		= fread_number( fp );\n	pObjIndex->value[2]		= fread_number( fp );\n	pObjIndex->value[3]		= fread_number( fp );\n	pObjIndex->value[4]		= 0;\n	pObjIndex->level		= 0;\n	pObjIndex->condition 		= 100;\n	pObjIndex->weight		= fread_number( fp );\n	pObjIndex->cost			= fread_number( fp );	/* Unused */\n	/* Cost per day */		  fread_number( fp );\n\n\n	if (pObjIndex->item_type == ITEM_WEAPON)\n	{\n		if (is_name(\"two\",pObjIndex->name) \n		||  is_name(\"two-handed\",pObjIndex->name) \n		||  is_name(\"claymore\",pObjIndex->name))\n		SET_BIT(pObjIndex->value[4],WEAPON_TWO_HANDS);\n	}\n\n	for ( ; ; )\n	{\n		char letter;\n\n		letter = fread_letter( fp );\n\n		if ( letter == 'A' )\n		{\n		AFFECT_DATA *paf;\n\n		paf			= alloc_perm( sizeof(*paf) );\n		paf->where		= TO_OBJECT;\n		paf->type		= -1;\n		paf->level		= 20; /* RT temp fix */\n		paf->duration		= -1;\n		paf->location		= fread_number( fp );\n		paf->modifier		= fread_number( fp );\n		paf->bitvector		= 0;\n		paf->next		= pObjIndex->affected;\n		pObjIndex->affected	= paf;\n		top_affect++;\n		}\n\n		else if ( letter == 'E' )\n		{\n		EXTRA_DESCR_DATA *ed;\n\n		ed			= alloc_perm( sizeof(*ed) );\n		ed->keyword		= fread_string( fp );\n		ed->description		= fread_string( fp );\n		ed->next		= pObjIndex->extra_descr;\n		pObjIndex->extra_descr	= ed;\n		top_ed++;\n		}\n\n		else\n		{\n		ungetc( letter, fp );\n		break;\n		}\n	}\n\n		/* fix armors */\n		if (pObjIndex->item_type == ITEM_ARMOR)\n		{\n			pObjIndex->value[1] = pObjIndex->value[0];\n			pObjIndex->value[2] = pObjIndex->value[1];\n		}\n\n	/*\n	 * Translate spell \"slot numbers\" to internal \"skill numbers.\"\n	 */\n	switch ( pObjIndex->item_type )\n	{\n	case ITEM_PILL:\n	case ITEM_POTION:\n	case ITEM_SCROLL:\n		pObjIndex->value[1] = slot_lookup( pObjIndex->value[1] );\n		pObjIndex->value[2] = slot_lookup( pObjIndex->value[2] );\n		pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );\n		pObjIndex->value[4] = slot_lookup( pObjIndex->value[4] );\n		break;\n\n	case ITEM_STAFF:\n	case ITEM_WAND:\n		pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );\n		break;\n	}\n\n	iHash			= vnum % MAX_KEY_HASH;\n	pObjIndex->next		= obj_index_hash[iHash];\n	obj_index_hash[iHash]	= pObjIndex;\n	top_obj_index++;\n		top_vnum_obj = top_vnum_obj < vnum ? vnum : top_vnum_obj;   /* OLC */\n		assign_area_vnum( vnum );                                   /* OLC */\n	}\n\n	return;\n}\n\n/*\n * Adds a reset to a room.  OLC\n * Similar to add_reset in olc.c\n */\nvoid new_reset( ROOM_INDEX_DATA *pR, RESET_DATA *pReset )\n{\n	RESET_DATA *pr;\n\n	if ( !pR )\n	   return;\n\n	pr = pR->reset_last;\n\n	if ( !pr )\n	{\n		pR->reset_first = pReset;\n		pR->reset_last  = pReset;\n	}\n	else\n	{\n		pR->reset_last->next = pReset;\n		pR->reset_last       = pReset;\n		pR->reset_last->next = NULL;\n	}\n\n/*    top_reset++; no estamos asignando memoria!!!! */\n\n	return;\n}\n\n/*\n * Snarf a reset section.\n */\nvoid load_resets( FILE *fp )\n{\n	RESET_DATA *pReset;\n	EXIT_DATA *pexit;\n	ROOM_INDEX_DATA *pRoomIndex;\n	int rVnum = -1;\n\n	if ( !area_last )\n	{\n	bug( \"Load_resets: no #AREA seen yet.\", 0 );\n	exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n	char letter;\n\n	if ( ( letter = fread_letter( fp ) ) == 'S' )\n		break;\n\n	if ( letter == '*' )\n	{\n		fread_to_eol( fp );\n		continue;\n	}\n\n	pReset		= new_reset_data();\n	pReset->command	= letter;\n	/* if_flag */	  fread_number( fp );\n	pReset->arg1	= fread_number( fp );\n	pReset->arg2	= fread_number( fp );\n	pReset->arg3	= (letter == 'G' || letter == 'R')\n				? 0 : fread_number( fp );\n	pReset->arg4	= (letter == 'P' || letter == 'M')\n				? fread_number(fp) : 0;\n			  fread_to_eol( fp );\n\n	switch( pReset->command )\n	{\n		case 'M':\n		case 'O':\n		rVnum = pReset->arg3;\n		break;\n\n		case 'P':\n		case 'G':\n		case 'E':\n		break;\n\n		case 'D':\n		pRoomIndex = get_room_index( (rVnum = pReset->arg1) );\n		if ( pReset->arg2 < 0\n		||   pReset->arg2 >= MAX_DIR\n		|| !pRoomIndex\n		|| !( pexit = pRoomIndex->exit[pReset->arg2] )\n		|| !IS_SET( pexit->rs_flags, EX_ISDOOR ) )\n		{\n			bugf( \"Load_resets: 'D': exit %d, room %d not door.\", pReset->arg2, pReset->arg1 );\n			exit( 1 );\n		}\n\n		switch ( pReset->arg3 )\n		{\n			default: bug( \"Load_resets: 'D': bad 'locks': %d.\" , pReset->arg3); break;\n			case 0: break;\n			case 1: SET_BIT( pexit->rs_flags, EX_CLOSED );\n				SET_BIT( pexit->exit_info, EX_CLOSED ); break;\n			case 2: SET_BIT( pexit->rs_flags, EX_CLOSED | EX_LOCKED );\n				SET_BIT( pexit->exit_info, EX_CLOSED | EX_LOCKED ); break;\n		}\n		break;\n\n		case 'R':\n		rVnum = pReset->arg1;\n		break;\n	}\n\n	if ( rVnum == -1 )\n	{\n		bugf( \"load_resets : rVnum == -1\" );\n		exit(1);\n	}\n\n	if ( pReset->command != 'D' )\n		new_reset( get_room_index(rVnum), pReset );\n	else\n		free_reset_data( pReset );\n	}\n\n	return;\n}\n\n/*\n * Snarf a room section.\n */\nvoid load_rooms( FILE *fp )\n{\n	ROOM_INDEX_DATA *pRoomIndex;\n\n	if ( area_last == NULL )\n	{\n	bug( \"Load_resets: no #AREA seen yet.\", 0 );\n	exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n	sh_int vnum;\n	char letter;\n	int door;\n	int iHash;\n\n	letter				= fread_letter( fp );\n	if ( letter != '#' )\n	{\n		bug( \"Load_rooms: # not found.\", 0 );\n		exit( 1 );\n	}\n\n	vnum				= fread_number( fp );\n	if ( vnum == 0 )\n		break;\n\n	fBootDb = FALSE;\n	if ( get_room_index( vnum ) != NULL )\n	{\n		bug( \"Load_rooms: vnum %d duplicated.\", vnum );\n		exit( 1 );\n	}\n	fBootDb = TRUE;\n\n	pRoomIndex			= alloc_perm( sizeof(*pRoomIndex) );\n	pRoomIndex->owner		= NULL;\n	pRoomIndex->people		= NULL;\n	pRoomIndex->contents		= NULL;\n	pRoomIndex->extra_descr		= NULL;\n	pRoomIndex->area		= area_last;\n	pRoomIndex->vnum		= vnum;\n	pRoomIndex->name		= fread_string( fp );\n	pRoomIndex->description		= fread_string( fp );\n	/* Area number */		  fread_number( fp );\n	pRoomIndex->room_flags		= fread_flag( fp );\n	/* horrible hack */\n	if ( 3000 <= vnum && vnum < 3400)\n	   SET_BIT(pRoomIndex->room_flags,ROOM_LAW);\n	pRoomIndex->sector_type		= fread_number( fp );\n	pRoomIndex->light		= 0;\n	for ( door = 0; door <= 5; door++ )\n		pRoomIndex->exit[door] = NULL;\n\n	/* defaults */\n	pRoomIndex->heal_rate = 100;\n	pRoomIndex->mana_rate = 100;\n\n	for ( ; ; )\n	{\n		letter = fread_letter( fp );\n\n		if ( letter == 'S' )\n		break;\n\n		if ( letter == 'H') /* healing room */\n		pRoomIndex->heal_rate = fread_number(fp);\n	\n		else if ( letter == 'M') /* mana room */\n		pRoomIndex->mana_rate = fread_number(fp);\n\n	   else if ( letter == 'C') /* clan */\n	   {\n		if (pRoomIndex->clan)\n		{\n			bug(\"Load_rooms: duplicate clan fields.\",0);\n			exit(1);\n		}\n		pRoomIndex->clan = clan_lookup(fread_string(fp));\n		}\n	\n\n		else if ( letter == 'D' )\n		{\n		EXIT_DATA *pexit;\n		int locks;\n\n		door = fread_number( fp );\n		if ( door < 0 || door > 5 )\n		{\n			bug( \"Fread_rooms: vnum %d has bad door number.\", vnum );\n			exit( 1 );\n		}\n\n		pexit			= alloc_perm( sizeof(*pexit) );\n		pexit->description	= fread_string( fp );\n		pexit->keyword		= fread_string( fp );\n		pexit->exit_info	= 0;\n				pexit->rs_flags         = 0;                    /* OLC */\n		locks			= fread_number( fp );\n		pexit->key		= fread_number( fp );\n		pexit->u1.vnum		= fread_number( fp );\n		pexit->orig_door	= door;			/* OLC */\n\n		switch ( locks )\n		{\n		case 1: pexit->exit_info = EX_ISDOOR;               \n			pexit->rs_flags  = EX_ISDOOR;		     break;\n		case 2: pexit->exit_info = EX_ISDOOR | EX_PICKPROOF;\n			pexit->rs_flags  = EX_ISDOOR | EX_PICKPROOF; break;\n		case 3: pexit->exit_info = EX_ISDOOR | EX_NOPASS;    \n			pexit->rs_flags  = EX_ISDOOR | EX_NOPASS;    break;\n		case 4: pexit->exit_info = EX_ISDOOR|EX_NOPASS|EX_PICKPROOF;\n			pexit->rs_flags  = EX_ISDOOR|EX_NOPASS|EX_PICKPROOF;\n			break;\n		}\n\n		pRoomIndex->exit[door]	= pexit;\n		top_exit++;\n		}\n		else if ( letter == 'E' )\n		{\n		EXTRA_DESCR_DATA *ed;\n\n		ed			= alloc_perm( sizeof(*ed) );\n		ed->keyword		= fread_string( fp );\n		ed->description		= fread_string( fp );\n		ed->next		= pRoomIndex->extra_descr;\n		pRoomIndex->extra_descr	= ed;\n		top_ed++;\n		}\n\n		else if (letter == 'O')\n		{\n		if (pRoomIndex->owner[0] != '\\0')\n		{\n			bug(\"Load_rooms: duplicate owner.\",0);\n			exit(1);\n		}\n\n		pRoomIndex->owner = fread_string(fp);\n		}\n\n		else\n		{\n		bug( \"Load_rooms: vnum %d has flag not 'DES'.\", vnum );\n		exit( 1 );\n		}\n	}\n\n	iHash			= vnum % MAX_KEY_HASH;\n	pRoomIndex->next	= room_index_hash[iHash];\n	room_index_hash[iHash]	= pRoomIndex;\n	top_room++;\n		top_vnum_room = top_vnum_room < vnum ? vnum : top_vnum_room; /* OLC */\n		assign_area_vnum( vnum );                                    /* OLC */\n	}\n\n	return;\n}\n\n\n\n/*\n * Snarf a shop section.\n */\nvoid load_shops( FILE *fp )\n{\n	SHOP_DATA *pShop;\n\n	for ( ; ; )\n	{\n	MOB_INDEX_DATA *pMobIndex;\n	int iTrade;\n\n	pShop			= alloc_perm( sizeof(*pShop) );\n	pShop->keeper		= fread_number( fp );\n	if ( pShop->keeper == 0 )\n		break;\n	for ( iTrade = 0; iTrade < MAX_TRADE; iTrade++ )\n		pShop->buy_type[iTrade]	= fread_number( fp );\n	pShop->profit_buy	= fread_number( fp );\n	pShop->profit_sell	= fread_number( fp );\n	pShop->open_hour	= fread_number( fp );\n	pShop->close_hour	= fread_number( fp );\n				  fread_to_eol( fp );\n	pMobIndex		= get_mob_index( pShop->keeper );\n	pMobIndex->pShop	= pShop;\n\n	if ( shop_first == NULL )\n		shop_first = pShop;\n	if ( shop_last  != NULL )\n		shop_last->next = pShop;\n\n	shop_last	= pShop;\n	pShop->next	= NULL;\n	top_shop++;\n	}\n\n	return;\n}\n\n\n/*\n * Snarf spec proc declarations.\n */\nvoid load_specials( FILE *fp )\n{\n	for ( ; ; )\n	{\n	MOB_INDEX_DATA *pMobIndex;\n	char letter;\n\n	switch ( letter = fread_letter( fp ) )\n	{\n	default:\n		bug( \"Load_specials: letter '%c' not *MS.\", letter );\n		exit( 1 );\n\n	case 'S':\n		return;\n\n	case '*':\n		break;\n\n	case 'M':\n		pMobIndex		= get_mob_index	( fread_number ( fp ) );\n		pMobIndex->spec_fun	= spec_lookup	( fread_word   ( fp ) );\n		if ( pMobIndex->spec_fun == 0 )\n		{\n		bug( \"Load_specials: 'M': vnum %d.\", pMobIndex->vnum );\n		exit( 1 );\n		}\n		break;\n	}\n\n	fread_to_eol( fp );\n	}\n}\n\n\n/*\n * Translate all room exits from virtual to real.\n * Has to be done after all rooms are read in.\n * Check for bad reverse exits.\n */\nvoid fix_exits( void )\n{\n	extern const sh_int rev_dir [];\n	char buf[MAX_STRING_LENGTH];\n	ROOM_INDEX_DATA *pRoomIndex;\n	ROOM_INDEX_DATA *to_room;\n	EXIT_DATA *pexit;\n	EXIT_DATA *pexit_rev;\n	RESET_DATA *pReset;\n	ROOM_INDEX_DATA *iLastRoom, *iLastObj;\n	int iHash;\n	int door;\n\n	for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )\n	{\n	for ( pRoomIndex  = room_index_hash[iHash];\n		  pRoomIndex != NULL;\n		  pRoomIndex  = pRoomIndex->next )\n	{\n		bool fexit;\n\n		iLastRoom = iLastObj = NULL;\n\n		/* OLC : nuevo chequeo de resets */\n		for ( pReset = pRoomIndex->reset_first; pReset; pReset = pReset->next )\n		{\n			switch( pReset->command )\n			{\n				default:\n				bugf( \"fix_exits : cuarto %d con reset cmd %c\", pRoomIndex->vnum, pReset->command );\n				exit(1);\n				break;\n\n			case 'M':\n			get_mob_index( pReset->arg1 );\n			iLastRoom = get_room_index( pReset->arg3 );\n			break;\n\n			case 'O':\n			get_obj_index( pReset->arg1 );\n			iLastObj = get_room_index( pReset->arg3 );\n			break;\n\n			case 'P':\n			get_obj_index( pReset->arg1 );\n			if (iLastObj == NULL)\n			{\n				bugf( \"fix_exits : reset en cuarto %d con iLastObj NULL\", pRoomIndex->vnum );\n				exit(1);\n			}\n			break;\n\n			case 'G':\n			case 'E':\n			get_obj_index( pReset->arg1 );\n			if (iLastRoom == NULL)\n			{\n				bugf( \"fix_exits : reset en cuarto %d con iLastRoom NULL\", pRoomIndex->vnum );\n				exit(1);\n			}\n			iLastObj = iLastRoom;\n			break;\n\n			case 'D':\n			bugf( \"???\" );\n			break;\n\n			case 'R':\n			get_room_index( pReset->arg1 );\n			if ( pReset->arg2 < 0 || pReset->arg2 > MAX_DIR )\n			{\n				bugf( \"fix_exits : reset en cuarto %d con arg2 %d >= MAX_DIR\",\n					pRoomIndex->vnum, pReset->arg2 );\n				exit(1);\n			}\n			break;\n		} /* switch */\n		} /* for */\n\n		fexit = FALSE;\n		for ( door = 0; door <= 5; door++ )\n		{\n		if ( ( pexit = pRoomIndex->exit[door] ) != NULL )\n		{\n			if ( pexit->u1.vnum <= 0 \n			|| get_room_index(pexit->u1.vnum) == NULL)\n			pexit->u1.to_room = NULL;\n			else\n			{\n			fexit = TRUE; \n			pexit->u1.to_room = get_room_index( pexit->u1.vnum );\n			}\n		}\n		}\n		if (!fexit)\n		SET_BIT(pRoomIndex->room_flags,ROOM_NO_MOB);\n	}\n	}\n\n	for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )\n	{\n	for ( pRoomIndex  = room_index_hash[iHash];\n		  pRoomIndex != NULL;\n		  pRoomIndex  = pRoomIndex->next )\n	{\n		for ( door = 0; door <= 5; door++ )\n		{\n		if ( ( pexit     = pRoomIndex->exit[door]       ) != NULL\n		&&   ( to_room   = pexit->u1.to_room            ) != NULL\n		&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL\n		&&   pexit_rev->u1.to_room != pRoomIndex \n		&&   (pRoomIndex->vnum < 1200 || pRoomIndex->vnum > 1299))\n		{\n			sprintf( buf, \"Fix_exits: %d:%d -> %d:%d -> %d.\",\n			pRoomIndex->vnum, door,\n			to_room->vnum,    rev_dir[door],\n			(pexit_rev->u1.to_room == NULL)\n				? 0 : pexit_rev->u1.to_room->vnum );\n			bug( buf, 0 );\n		}\n		}\n	}\n	}\n\n	return;\n}\n\n/*\n * Load mobprogs section\n */\nvoid load_mobprogs( FILE *fp )\n{\n	MPROG_CODE *pMprog;\n\n	if ( area_last == NULL )\n	{\n	bug( \"Load_mobprogs: no #AREA seen yet.\", 0 );\n	exit( 1 );\n	}\n\n	for ( ; ; )\n	{\n	sh_int vnum;\n	char letter;\n\n	letter		  = fread_letter( fp );\n	if ( letter != '#' )\n	{\n		bug( \"Load_mobprogs: # not found.\", 0 );\n		exit( 1 );\n	}\n\n	vnum		 = fread_number( fp );\n	if ( vnum == 0 )\n		break;\n\n	fBootDb = FALSE;\n	if ( get_mprog_index( vnum ) != NULL )\n	{\n		bug( \"Load_mobprogs: vnum %d duplicated.\", vnum );\n		exit( 1 );\n	}\n	fBootDb = TRUE;\n\n	pMprog		= alloc_perm( sizeof(*pMprog) );\n	pMprog->vnum  	= vnum;\n	pMprog->code  	= fread_string( fp );\n	if ( mprog_list == NULL )\n		mprog_list = pMprog;\n	else\n	{\n		pMprog->next = mprog_list;\n		mprog_list 	= pMprog;\n	}\n	top_mprog_index++;\n	}\n	return;\n}\n\n/*\n *  Translate mobprog vnums pointers to real code\n */\nvoid fix_mobprogs( void )\n{\n	MOB_INDEX_DATA *pMobIndex;\n	MPROG_LIST        *list;\n	MPROG_CODE        *prog;\n	int iHash;\n\n	for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )\n	{\n	for ( pMobIndex   = mob_index_hash[iHash];\n		  pMobIndex   != NULL;\n		  pMobIndex   = pMobIndex->next )\n	{\n		for( list = pMobIndex->mprogs; list != NULL; list = list->next )\n		{\n		if ( ( prog = get_mprog_index( list->vnum ) ) != NULL )\n			list->code = prog->code;\n		else\n		{\n			bug( \"Fix_mobprogs: code vnum %d not found.\", list->vnum );\n			exit( 1 );\n		}\n		}\n	}\n	}\n}\n\n\n/*\n * Repopulate areas periodically.\n */\nvoid area_update( void )\n{\n	AREA_DATA *pArea;\n	char buf[MAX_STRING_LENGTH];\n\n	for ( pArea = area_first; pArea != NULL; pArea = pArea->next )\n	{\n\n	if ( ++pArea->age < 3 )\n		continue;\n\n	/*\n	 * Check age and reset.\n	 * Note: Mud School resets every 3 minutes (not 15).\n	 */\n	if ( (!pArea->empty && (pArea->nplayer == 0 || pArea->age >= 15))\n	||    pArea->age >= 31)\n	{\n		ROOM_INDEX_DATA *pRoomIndex;\n\n		reset_area( pArea );\n		sprintf(buf,\"%s has just been reset.\",pArea->name);\n		wiznet(buf,NULL,NULL,WIZ_RESETS,0,0);\n	\n		pArea->age = number_range( 0, 3 );\n		pRoomIndex = get_room_index( ROOM_VNUM_SCHOOL );\n		if ( pRoomIndex != NULL && pArea == pRoomIndex->area )\n		pArea->age = 15 - 2;\n		else if (pArea->nplayer == 0) \n		pArea->empty = TRUE;\n	}\n	}\n\n	return;\n}\n\n/* OLC\n * Reset one room.  Called by reset_area and olc.\n */\nvoid reset_room( ROOM_INDEX_DATA *pRoom )\n{\n	RESET_DATA  *pReset;\n	CHAR_DATA   *pMob;\n	CHAR_DATA	*mob;\n	OBJ_DATA    *pObj;\n	CHAR_DATA   *LastMob = NULL;\n	OBJ_DATA    *LastObj = NULL;\n	int iExit;\n	int level = 0;\n	bool last;\n\n	if ( !pRoom )\n		return;\n\n	pMob        = NULL;\n	last        = FALSE;\n	\n	for ( iExit = 0;  iExit < MAX_DIR;  iExit++ )\n	{\n		EXIT_DATA *pExit;\n		if ( ( pExit = pRoom->exit[iExit] )\n	  /*  && !IS_SET( pExit->exit_info, EX_BASHED )   ROM OLC */ )  \n		{\n			pExit->exit_info = pExit->rs_flags;\n			if ( ( pExit->u1.to_room != NULL )\n			  && ( ( pExit = pExit->u1.to_room->exit[rev_dir[iExit]] ) ) )\n			{\n				/* nail the other side */\n				pExit->exit_info = pExit->rs_flags;\n			}\n		}\n	}\n\n	for ( pReset = pRoom->reset_first; pReset != NULL; pReset = pReset->next )\n	{\n		MOB_INDEX_DATA  *pMobIndex;\n		OBJ_INDEX_DATA  *pObjIndex;\n		OBJ_INDEX_DATA  *pObjToIndex;\n		ROOM_INDEX_DATA *pRoomIndex;\n	char buf[MAX_STRING_LENGTH];\n	int count,limit=0;\n\n		switch ( pReset->command )\n		{\n		default:\n				bug( \"Reset_room: bad command %c.\", pReset->command );\n				break;\n\n		case 'M':\n			if ( !( pMobIndex = get_mob_index( pReset->arg1 ) ) )\n			{\n				bug( \"Reset_room: 'M': bad vnum %d.\", pReset->arg1 );\n				continue;\n			}\n\n		if ( ( pRoomIndex = get_room_index( pReset->arg3 ) ) == NULL )\n		{\n		bug( \"Reset_area: 'R': bad vnum %d.\", pReset->arg3 );\n		continue;\n		}\n			if ( pMobIndex->count >= pReset->arg2 )\n			{\n				last = FALSE;\n				break;\n			}\n/* */\n		count = 0;\n		for (mob = pRoomIndex->people; mob != NULL; mob = mob->next_in_room)\n		if (mob->pIndexData == pMobIndex)\n		{\n			count++;\n			if (count >= pReset->arg4)\n			{\n				last = FALSE;\n				break;\n			}\n		}\n\n		if (count >= pReset->arg4)\n		break;\n\n/* */\n\n			pMob = create_mobile( pMobIndex );\n\n			/*\n			 * Some more hard coding.\n			 */\n			if ( room_is_dark( pRoom ) )\n				SET_BIT(pMob->affected_by, AFF_INFRARED);\n\n			/*\n			 * Pet shop mobiles get ACT_PET set.\n			 */\n			{\n				ROOM_INDEX_DATA *pRoomIndexPrev;\n\n				pRoomIndexPrev = get_room_index( pRoom->vnum - 1 );\n				if ( pRoomIndexPrev\n					&& IS_SET( pRoomIndexPrev->room_flags, ROOM_PET_SHOP ) )\n					SET_BIT( pMob->act, ACT_PET);\n			}\n\n			char_to_room( pMob, pRoom );\n\n			LastMob = pMob;\n			level  = URANGE( 0, pMob->level - 2, LEVEL_HERO - 1 ); /* -1 ROM */\n			last = TRUE;\n			break;\n\n		case 'O':\n			if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )\n			{\n				bug( \"Reset_room: 'O' 1 : bad vnum %d\", pReset->arg1 );\n				sprintf (buf,\"%d %d %d %d\",pReset->arg1, pReset->arg2, pReset->arg3,\n				pReset->arg4 );\n		bug(buf,1);\n				continue;\n			}\n\n			if ( !( pRoomIndex = get_room_index( pReset->arg3 ) ) )\n			{\n				bug( \"Reset_room: 'O' 2 : bad vnum %d.\", pReset->arg3 );\n				sprintf (buf,\"%d %d %d %d\",pReset->arg1, pReset->arg2, pReset->arg3,\n				pReset->arg4 );\n		bug(buf,1);\n				continue;\n			}\n\n			if ( pRoom->area->nplayer > 0\n			  || count_obj_list( pObjIndex, pRoom->contents ) > 0 )\n		{\n		last = FALSE;\n		break;\n		}\n\n			pObj = create_object( pObjIndex,              /* UMIN - ROM OLC */\n				  UMIN(number_fuzzy( level ), LEVEL_HERO -1) );\n			pObj->cost = 0;\n			obj_to_room( pObj, pRoom );\n		last = TRUE;\n			break;\n\n		case 'P':\n			if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )\n			{\n				bug( \"Reset_room: 'P': bad vnum %d.\", pReset->arg1 );\n				continue;\n			}\n\n			if ( !( pObjToIndex = get_obj_index( pReset->arg3 ) ) )\n			{\n				bug( \"Reset_room: 'P': bad vnum %d.\", pReset->arg3 );\n				continue;\n			}\n\n			if (pReset->arg2 > 50) /* old format */\n				limit = 6;\n			else if (pReset->arg2 == -1) /* no limit */\n				limit = 999;\n			else\n				limit = pReset->arg2;\n\n			if ( pRoom->area->nplayer > 0\n			  || ( LastObj = get_obj_type( pObjToIndex ) ) == NULL\n			  || ( LastObj->in_room == NULL && !last)\n			  || ( pObjIndex->count >= limit /* && number_range(0,4) != 0 */ )\n			  || ( count = count_obj_list( pObjIndex, LastObj->contains ) ) > pReset->arg4  )\n		{\n		last = FALSE;\n		break;\n		}\n								/* lastObj->level  -  ROM */\n\n		while (count < pReset->arg4)\n		{\n			pObj = create_object( pObjIndex, number_fuzzy( LastObj->level ) );\n			obj_to_obj( pObj, LastObj );\n		count++;\n		if (pObjIndex->count >= limit)\n			break;\n		}\n\n		/* fix object lock state! */\n		LastObj->value[1] = LastObj->pIndexData->value[1];\n		last = TRUE;\n			break;\n\n		case 'G':\n		case 'E':\n			if ( !( pObjIndex = get_obj_index( pReset->arg1 ) ) )\n			{\n				bug( \"Reset_room: 'E' or 'G': bad vnum %d.\", pReset->arg1 );\n				continue;\n			}\n\n			if ( !last )\n				break;\n\n			if ( !LastMob )\n			{\n				bug( \"Reset_room: 'E' or 'G': null mob for vnum %d.\",\n					pReset->arg1 );\n				last = FALSE;\n				break;\n			}\n\n			if ( LastMob->pIndexData->pShop )   /* Shop-keeper? */\n			{\n				int olevel=0,i,j;\n\n		if (!pObjIndex->new_format)\n				 switch ( pObjIndex->item_type )\n				{\n				default:                olevel = 0;                      break;\n				case ITEM_PILL:\n				case ITEM_POTION:\n				case ITEM_SCROLL:\n			olevel = 53;\n			for (i = 1; i < 5; i++)\n			{\n			if (pObjIndex->value[i] > 0)\n			{\n					for (j = 0; j < MAX_CLASS; j++)\n				{\n				olevel = UMIN(olevel,\n						 skill_table[pObjIndex->value[i]].\n							 skill_level[j]);\n				}\n			}\n			}\n		   \n			olevel = UMAX(0,(olevel * 3 / 4) - 2);\n			break;\n			\n			   case ITEM_WAND:         olevel = number_range( 10, 20 ); break;\n				case ITEM_STAFF:        olevel = number_range( 15, 25 ); break;\n				case ITEM_ARMOR:        olevel = number_range(  5, 15 ); break;\n				/* ROM patch weapon, treasure */\n		case ITEM_WEAPON:       olevel = number_range(  5, 15 ); break;\n		case ITEM_TREASURE:     olevel = number_range( 10, 20 ); break;\n\n#if 0 /* envy version */\n				case ITEM_WEAPON:       if ( pReset->command == 'G' )\n											olevel = number_range( 5, 15 );\n										else\n											olevel = number_fuzzy( level );\n#endif /* envy version */\n\n				  break;\n				}\n\n				pObj = create_object( pObjIndex, olevel );\n		SET_BIT( pObj->extra_flags, ITEM_INVENTORY );  /* ROM OLC */\n\n#if 0 /* envy version */\n				if ( pReset->command == 'G' )\n					SET_BIT( pObj->extra_flags, ITEM_INVENTORY );\n#endif /* envy version */\n\n			}\n		else   /* ROM OLC else version */\n		{\n		int limit;\n		if (pReset->arg2 > 50 )  /* old format */\n			limit = 6;\n		else if ( pReset->arg2 == -1 || pReset->arg2 == 0 )  /* no limit */\n			limit = 999;\n		else\n			limit = pReset->arg2;\n\n		if ( pObjIndex->count < limit || number_range(0,4) == 0 )\n		{\n			pObj = create_object( pObjIndex, \n			   UMIN( number_fuzzy( level ), LEVEL_HERO - 1 ) );\n			/* error message if it is too high */\n			if (pObj->level > LastMob->level + 3\n			||  (pObj->item_type == ITEM_WEAPON \n			&&   pReset->command == 'E' \n			&&   pObj->level < LastMob->level -5 && pObj->level < 45))\n			fprintf(stderr,\n				\"Err: obj %s (%d) -- %d, mob %s (%d) -- %d\\n\",\n				pObj->short_descr,pObj->pIndexData->vnum,pObj->level,\n				LastMob->short_descr,LastMob->pIndexData->vnum,LastMob->level);\n		}\n		else\n			break;\n		}\n									 \n#if 0 /* envy else version */\n			else\n			{\n				pObj = create_object( pObjIndex, number_fuzzy( level ) );\n			}\n#endif /* envy else version */\n\n			obj_to_char( pObj, LastMob );\n			if ( pReset->command == 'E' )\n				equip_char( LastMob, pObj, pReset->arg3 );\n			last = TRUE;\n			break;\n\n		case 'D':\n			break;\n\n		case 'R':\n			if ( !( pRoomIndex = get_room_index( pReset->arg1 ) ) )\n			{\n				bug( \"Reset_room: 'R': bad vnum %d.\", pReset->arg1 );\n				continue;\n			}\n\n			{\n				EXIT_DATA *pExit;\n				int d0;\n				int d1;\n\n				for ( d0 = 0; d0 < pReset->arg2 - 1; d0++ )\n				{\n					d1                   = number_range( d0, pReset->arg2-1 );\n					pExit                = pRoomIndex->exit[d0];\n					pRoomIndex->exit[d0] = pRoomIndex->exit[d1];\n					pRoomIndex->exit[d1] = pExit;\n				}\n			}\n			break;\n		}\n	}\n\n	return;\n}\n\n/* OLC\n * Reset one area.\n */\nvoid reset_area( AREA_DATA *pArea )\n{\n	ROOM_INDEX_DATA *pRoom;\n	int  vnum;\n\n	for ( vnum = pArea->min_vnum; vnum <= pArea->max_vnum; vnum++ )\n	{\n		if ( ( pRoom = get_room_index(vnum) ) )\n			reset_room(pRoom);\n	}\n\n	return;\n}\n\n/*\n * Create an instance of a mobile.\n */\nCHAR_DATA *create_mobile( MOB_INDEX_DATA *pMobIndex )\n{\n	CHAR_DATA *mob;\n	int i;\n	AFFECT_DATA af;\n\n	mobile_count++;\n\n	if ( pMobIndex == NULL )\n	{\n	bug( \"Create_mobile: NULL pMobIndex.\", 0 );\n	exit( 1 );\n	}\n\n	mob = new_char();\n\n	mob->pIndexData	= pMobIndex;\n\n	// PURGE_DATA(mob->description);\n	// PURGE_DATA(mob->name);\n	// PURGE_DATA(mob->short_descr);\n	// PURGE_DATA(mob->long_descr);\n\n	mob->name		= str_dup( pMobIndex->player_name );    /* OLC */\n	mob->short_descr	= str_dup( pMobIndex->short_descr );    /* OLC */\n	if(!IS_NULLSTR(pMobIndex->long_descr))\n	mob->long_descr	= str_dup( pMobIndex->long_descr );     /* OLC */\n	if(!IS_NULLSTR(pMobIndex->description))\n		mob->description	= str_dup( pMobIndex->description );    /* OLC */\n	mob->id		= get_mob_id();\n	mob->spec_fun	= pMobIndex->spec_fun;\n	mob->prompt		= NULL;\n	mob->mprog_target   = NULL;\n\n	if (pMobIndex->wealth == 0)\n	{\n	mob->silver = 0;\n	mob->gold   = 0;\n	}\n	else\n	{\n	long wealth;\n\n	wealth = number_range(pMobIndex->wealth/2, 3 * pMobIndex->wealth/2);\n	mob->gold = number_range(wealth/200,wealth/100);\n	mob->silver = wealth - (mob->gold * 100);\n	} \n\n	if (pMobIndex->new_format)\n	/* load in new style */\n	{\n	/* read from prototype */\n	mob->group		= pMobIndex->group;\n	mob->act 		= pMobIndex->act;\n	mob->comm		= COMM_NOCHANNELS|COMM_NOSHOUT|COMM_NOTELL;\n	mob->affected_by	= pMobIndex->affected_by;\n	mob->alignment		= pMobIndex->alignment;\n	mob->level		= pMobIndex->level;\n	mob->hitroll		= pMobIndex->hitroll;\n	mob->damroll		= pMobIndex->damage[DICE_BONUS];\n	mob->max_hit		= dice(pMobIndex->hit[DICE_NUMBER],\n					   pMobIndex->hit[DICE_TYPE])\n				  + pMobIndex->hit[DICE_BONUS];\n	mob->hit		= mob->max_hit;\n	mob->max_mana		= dice(pMobIndex->mana[DICE_NUMBER],\n					   pMobIndex->mana[DICE_TYPE])\n				  + pMobIndex->mana[DICE_BONUS];\n	mob->mana		= mob->max_mana;\n	mob->damage[DICE_NUMBER]= pMobIndex->damage[DICE_NUMBER];\n	mob->damage[DICE_TYPE]	= pMobIndex->damage[DICE_TYPE];\n	mob->dam_type		= pMobIndex->dam_type;\n		if (mob->dam_type == 0)\n			switch(number_range(1,3))\n			{\n				case (1): mob->dam_type = 3;        break;  /* slash */\n				case (2): mob->dam_type = 7;        break;  /* pound */\n				case (3): mob->dam_type = 11;       break;  /* pierce */\n			}\n	for (i = 0; i < 4; i++)\n		mob->armor[i]	= pMobIndex->ac[i]; \n	mob->off_flags		= pMobIndex->off_flags;\n	mob->imm_flags		= pMobIndex->imm_flags;\n	mob->res_flags		= pMobIndex->res_flags;\n	mob->vuln_flags		= pMobIndex->vuln_flags;\n	mob->start_pos		= pMobIndex->start_pos;\n	mob->default_pos	= pMobIndex->default_pos;\n	mob->sex		= pMobIndex->sex;\n		if (mob->sex == 3) /* random sex */\n			mob->sex = number_range(1,2);\n	mob->race		= pMobIndex->race;\n	mob->form		= pMobIndex->form;\n	mob->parts		= pMobIndex->parts;\n	mob->size		= pMobIndex->size;\n	mob->material		= str_dup(pMobIndex->material);\n\n	/* computed on the spot */\n\n		for (i = 0; i < MAX_STATS; i ++)\n			mob->perm_stat[i] = UMIN(25,11 + mob->level/4);\n			\n		if (IS_SET(mob->act,ACT_WARRIOR))\n		{\n			mob->perm_stat[STAT_STR] += 3;\n			mob->perm_stat[STAT_INT] -= 1;\n			mob->perm_stat[STAT_CON] += 2;\n		}\n		\n		if (IS_SET(mob->act,ACT_THIEF))\n		{\n			mob->perm_stat[STAT_DEX] += 3;\n			mob->perm_stat[STAT_INT] += 1;\n			mob->perm_stat[STAT_WIS] -= 1;\n		}\n		\n		if (IS_SET(mob->act,ACT_CLERIC))\n		{\n			mob->perm_stat[STAT_WIS] += 3;\n			mob->perm_stat[STAT_DEX] -= 1;\n			mob->perm_stat[STAT_STR] += 1;\n		}\n		\n		if (IS_SET(mob->act,ACT_MAGE))\n		{\n			mob->perm_stat[STAT_INT] += 3;\n			mob->perm_stat[STAT_STR] -= 1;\n			mob->perm_stat[STAT_DEX] += 1;\n		}\n		\n		if (IS_SET(mob->off_flags,OFF_FAST))\n			mob->perm_stat[STAT_DEX] += 2;\n			\n		mob->perm_stat[STAT_STR] += mob->size - SIZE_MEDIUM;\n		mob->perm_stat[STAT_CON] += (mob->size - SIZE_MEDIUM) / 2;\n\n	/* let's get some spell action */\n	if (IS_AFFECTED(mob,AFF_SANCTUARY))\n	{\n		af.where	 = TO_AFFECTS;\n		af.type      = skill_lookup(\"sanctuary\");\n		af.level     = mob->level;\n		af.duration  = -1;\n		af.location  = APPLY_NONE;\n		af.modifier  = 0;\n		af.bitvector = AFF_SANCTUARY;\n		affect_to_char( mob, &af );\n	}\n\n	if (IS_AFFECTED(mob,AFF_HASTE))\n	{\n		af.where	 = TO_AFFECTS;\n		af.type      = skill_lookup(\"haste\");\n			af.level     = mob->level;\n			af.duration  = -1;\n			af.location  = APPLY_DEX;\n			af.modifier  = 1 + (mob->level >= 18) + (mob->level >= 25) + \n			   (mob->level >= 32);\n			af.bitvector = AFF_HASTE;\n			affect_to_char( mob, &af );\n	}\n\n	if (IS_AFFECTED(mob,AFF_PROTECT_EVIL))\n	{\n		af.where	 = TO_AFFECTS;\n		af.type	 = skill_lookup(\"protection evil\");\n		af.level	 = mob->level;\n		af.duration	 = -1;\n		af.location	 = APPLY_SAVES;\n		af.modifier	 = -1;\n		af.bitvector = AFF_PROTECT_EVIL;\n		affect_to_char(mob,&af);\n	}\n\n		if (IS_AFFECTED(mob,AFF_PROTECT_GOOD))\n		{\n		af.where	 = TO_AFFECTS;\n			af.type      = skill_lookup(\"protection good\");\n			af.level     = mob->level;\n			af.duration  = -1;\n			af.location  = APPLY_SAVES;\n			af.modifier  = -1;\n			af.bitvector = AFF_PROTECT_GOOD;\n			affect_to_char(mob,&af);\n		}\n	}\n	else /* read in old format and convert */\n	{\n	mob->act		= pMobIndex->act;\n	mob->affected_by	= pMobIndex->affected_by;\n	mob->alignment		= pMobIndex->alignment;\n	mob->level		= pMobIndex->level;\n	mob->hitroll		= pMobIndex->hitroll;\n	mob->damroll		= 0;\n	mob->max_hit		= mob->level * 8 + number_range(\n					mob->level * mob->level/4,\n					mob->level * mob->level);\n	mob->max_hit *= .9;\n	mob->hit		= mob->max_hit;\n	mob->max_mana		= 100 + dice(mob->level,10);\n	mob->mana		= mob->max_mana;\n	switch(number_range(1,3))\n	{\n		case (1): mob->dam_type = 3; 	break;  /* slash */\n		case (2): mob->dam_type = 7;	break;  /* pound */\n		case (3): mob->dam_type = 11;	break;  /* pierce */\n	}\n	for (i = 0; i < 3; i++)\n		mob->armor[i]	= interpolate(mob->level,100,-100);\n	mob->armor[3]		= interpolate(mob->level,100,0);\n	mob->race		= pMobIndex->race;\n	mob->off_flags		= pMobIndex->off_flags;\n	mob->imm_flags		= pMobIndex->imm_flags;\n	mob->res_flags		= pMobIndex->res_flags;\n	mob->vuln_flags		= pMobIndex->vuln_flags;\n	mob->start_pos		= pMobIndex->start_pos;\n	mob->default_pos	= pMobIndex->default_pos;\n	mob->sex		= pMobIndex->sex;\n	mob->form		= pMobIndex->form;\n	mob->parts		= pMobIndex->parts;\n	mob->size		= SIZE_MEDIUM;\n	mob->material		= \"\";\n\n		for (i = 0; i < MAX_STATS; i ++)\n			mob->perm_stat[i] = 11 + mob->level/4;\n	}\n\n	mob->position = mob->start_pos;\n\n\n	/* link the mob to the world list */\n	mob->next		= char_list;\n	char_list		= mob;\n	pMobIndex->count++;\n	return mob;\n}\n\n/* duplicate a mobile exactly -- except inventory */\nvoid clone_mobile(CHAR_DATA *parent, CHAR_DATA *clone)\n{\n	int i;\n	AFFECT_DATA *paf;\n\n	if ( parent == NULL || clone == NULL || !IS_NPC(parent))\n	return;\n	\n	/* start fixing values */ \n	clone->name 	= str_dup(parent->name);\n	clone->version	= parent->version;\n	clone->short_descr	= str_dup(parent->short_descr);\n	clone->long_descr	= str_dup(parent->long_descr);\n	clone->description	= str_dup(parent->description);\n	clone->group	= parent->group;\n	clone->sex		= parent->sex;\n	clone->class	= parent->class;\n	clone->race		= parent->race;\n	clone->level	= parent->level;\n	clone->trust	= 0;\n	clone->timer	= parent->timer;\n	clone->wait		= parent->wait;\n	clone->hit		= parent->hit;\n	clone->max_hit	= parent->max_hit;\n	clone->mana		= parent->mana;\n	clone->max_mana	= parent->max_mana;\n	clone->move		= parent->move;\n	clone->max_move	= parent->max_move;\n	clone->gold		= parent->gold;\n	clone->silver	= parent->silver;\n	clone->exp		= parent->exp;\n	clone->act		= parent->act;\n	clone->comm		= parent->comm;\n	clone->imm_flags	= parent->imm_flags;\n	clone->res_flags	= parent->res_flags;\n	clone->vuln_flags	= parent->vuln_flags;\n	clone->invis_level	= parent->invis_level;\n	clone->affected_by	= parent->affected_by;\n	clone->position	= parent->position;\n	clone->practice	= parent->practice;\n	clone->train	= parent->train;\n	clone->saving_throw	= parent->saving_throw;\n	clone->alignment	= parent->alignment;\n	clone->hitroll	= parent->hitroll;\n	clone->damroll	= parent->damroll;\n	clone->wimpy	= parent->wimpy;\n	clone->form		= parent->form;\n	clone->parts	= parent->parts;\n	clone->size		= parent->size;\n	clone->material	= str_dup(parent->material);\n	clone->off_flags	= parent->off_flags;\n	clone->dam_type	= parent->dam_type;\n	clone->start_pos	= parent->start_pos;\n	clone->default_pos	= parent->default_pos;\n	clone->spec_fun	= parent->spec_fun;\n	\n	for (i = 0; i < 4; i++)\n		clone->armor[i]	= parent->armor[i];\n\n	for (i = 0; i < MAX_STATS; i++)\n	{\n	clone->perm_stat[i]	= parent->perm_stat[i];\n	clone->mod_stat[i]	= parent->mod_stat[i];\n	}\n\n	for (i = 0; i < 3; i++)\n	clone->damage[i]	= parent->damage[i];\n\n	/* now add the affects */\n	for (paf = parent->affected; paf != NULL; paf = paf->next)\n		affect_to_char(clone,paf);\n\n}\n\n\n\n\n/*\n * Create an instance of an object.\n */\n OBJ_DATA *create_object( OBJ_INDEX_DATA *pObjIndex, int level )\n {\n 	AFFECT_DATA *paf;\n 	OBJ_DATA *obj;\n 	int i;\n\n 	if ( pObjIndex == NULL )\n 	{\n 		bug( \"Create_object: NULL pObjIndex.\", 0 );\n 		exit( 1 );\n 	}\n\n 	obj = new_obj();\n\n 	obj->pIndexData	= pObjIndex;\n 	obj->in_room	= NULL;\n 	obj->enchanted	= FALSE;\n\n 	if (pObjIndex->new_format)\n 		obj->level = pObjIndex->level;\n 	else\n 		obj->level		= UMAX(0,level);\n 	obj->wear_loc	= -1;\n\n	obj->name		= str_dup( pObjIndex->name );           /* OLC */\n	obj->short_descr	= str_dup( pObjIndex->short_descr );    /* OLC */\n	if(!IS_NULLSTR(pObjIndex->description))\n		CopyTo( obj->description, pObjIndex->description);\n	else\n		obj->description = str_dup(\"This object needs a long description.\");\n\n 	if(!IS_NULLSTR(pObjIndex->material))\n 		obj->material	= str_dup(pObjIndex->material);\n 	obj->item_type	= pObjIndex->item_type;\n 	obj->extra_flags	= pObjIndex->extra_flags;\n 	obj->wear_flags	= pObjIndex->wear_flags;\n 	obj->value[0]	= pObjIndex->value[0];\n 	obj->value[1]	= pObjIndex->value[1];\n 	obj->value[2]	= pObjIndex->value[2];\n 	obj->value[3]	= pObjIndex->value[3];\n 	obj->value[4]	= pObjIndex->value[4];\n 	obj->weight		= pObjIndex->weight;\n\n 	if (level == -1 || pObjIndex->new_format)\n 		obj->cost	= pObjIndex->cost;\n 	else\n 		obj->cost	= number_fuzzy( 10 )\n 	* number_fuzzy( level ) * number_fuzzy( level );\n\n	/*\n	 * Mess with object properties.\n	 */\n	 switch ( obj->item_type )\n	 {\n	 	default:\n	 	bug( \"Read_object: vnum %d bad type.\", pObjIndex->vnum );\n	 	break;\n\n	 	case ITEM_LIGHT:\n	 	if (obj->value[2] == 999)\n	 		obj->value[2] = -1;\n	 	break;\n\n	 	case ITEM_FURNITURE:\n	 	case ITEM_TRASH:\n	 	case ITEM_CONTAINER:\n	 	case ITEM_DRINK_CON:\n	 	case ITEM_KEY:\n	 	case ITEM_FOOD:\n	 	case ITEM_BOAT:\n	 	case ITEM_CORPSE_NPC:\n	 	case ITEM_CORPSE_PC:\n	 	case ITEM_FOUNTAIN:\n	 	case ITEM_MAP:\n	 	case ITEM_CLOTHING:\n	 	case ITEM_PORTAL:\n	 	if (!pObjIndex->new_format)\n	 		obj->cost /= 5;\n	 	break;\n\n	 	case ITEM_TREASURE:\n	 	case ITEM_WARP_STONE:\n	 	case ITEM_ROOM_KEY:\n	 	case ITEM_GEM:\n	 	case ITEM_JEWELRY:\n	 	break;\n\n	 	case ITEM_JUKEBOX:\n	 	for (i = 0; i < 5; i++)\n	 		obj->value[i] = -1;\n	 	break;\n\n	 	case ITEM_SCROLL:\n	 	if (level != -1 && !pObjIndex->new_format)\n	 		obj->value[0]	= number_fuzzy( obj->value[0] );\n	 	break;\n\n	 	case ITEM_WAND:\n	 	case ITEM_STAFF:\n	 	if (level != -1 && !pObjIndex->new_format)\n	 	{\n	 		obj->value[0]	= number_fuzzy( obj->value[0] );\n	 		obj->value[1]	= number_fuzzy( obj->value[1] );\n	 		obj->value[2]	= obj->value[1];\n	 	}\n	 	if (!pObjIndex->new_format)\n	 		obj->cost *= 2;\n	 	break;\n\n	 	case ITEM_WEAPON:\n	 	if (level != -1 && !pObjIndex->new_format)\n	 	{\n	 		obj->value[1] = number_fuzzy( number_fuzzy( 1 * level / 4 + 2 ) );\n	 		obj->value[2] = number_fuzzy( number_fuzzy( 3 * level / 4 + 6 ) );\n	 	}\n	 	break;\n\n	 	case ITEM_ARMOR:\n	 	if (level != -1 && !pObjIndex->new_format)\n	 	{\n	 		obj->value[0]	= number_fuzzy( level / 5 + 3 );\n	 		obj->value[1]	= number_fuzzy( level / 5 + 3 );\n	 		obj->value[2]	= number_fuzzy( level / 5 + 3 );\n	 	}\n	 	break;\n\n	 	case ITEM_POTION:\n	 	case ITEM_PILL:\n	 	if (level != -1 && !pObjIndex->new_format)\n	 		obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );\n	 	break;\n\n	 	case ITEM_MONEY:\n	 	if (!pObjIndex->new_format)\n	 		obj->value[0]	= obj->cost;\n	 	break;\n	 }\n\n	 for (paf = pObjIndex->affected; paf != NULL; paf = paf->next) \n	 	if ( paf->location == APPLY_SPELL_AFFECT )\n	 		affect_to_obj(obj,paf);\n\n	 	obj->next		= object_list;\n	 	object_list		= obj;\n	 	pObjIndex->count++;\n\n	 	return obj;\n	 }\n\n/* duplicate an object exactly -- except contents */\nvoid clone_object(OBJ_DATA *parent, OBJ_DATA *clone)\n{\n	int i;\n	AFFECT_DATA *paf;\n	EXTRA_DESCR_DATA *ed,*ed_new;\n\n	if (parent == NULL || clone == NULL)\n	return;\n\n	/* start fixing the object */\n	clone->name 	= str_dup(parent->name);\n	clone->short_descr 	= str_dup(parent->short_descr);\n	clone->description	= str_dup(parent->description);\n	clone->item_type	= parent->item_type;\n	clone->extra_flags	= parent->extra_flags;\n	clone->wear_flags	= parent->wear_flags;\n	clone->weight	= parent->weight;\n	clone->cost		= parent->cost;\n	clone->level	= parent->level;\n	clone->condition	= parent->condition;\n	clone->material	= str_dup(parent->material);\n	clone->timer	= parent->timer;\n\n	for (i = 0;  i < 5; i ++)\n	clone->value[i]	= parent->value[i];\n\n	/* affects */\n	clone->enchanted	= parent->enchanted;\n  \n	for (paf = parent->affected; paf != NULL; paf = paf->next) \n	affect_to_obj(clone,paf);\n\n	/* extended desc */\n	for (ed = parent->extra_descr; ed != NULL; ed = ed->next)\n	{\n		ed_new                  = new_extra_descr();\n		ed_new->keyword    	= str_dup( ed->keyword);\n		ed_new->description     = str_dup( ed->description );\n		ed_new->next           	= clone->extra_descr;\n		clone->extra_descr  	= ed_new;\n	}\n\n}\n\n\n\n/*\n * Clear a new character.\n */\nvoid clear_char( CHAR_DATA *ch )\n{\n	static CHAR_DATA ch_zero;\n	int i;\n\n	*ch				= ch_zero;\n	ch->name			= &str_empty[0];\n	ch->short_descr		= &str_empty[0];\n	ch->long_descr		= &str_empty[0];\n	ch->description		= &str_empty[0];\n	ch->prompt                  = &str_empty[0];\n	ch->logon			= current_time;\n	ch->lines			= PAGELEN;\n	for (i = 0; i < 4; i++)\n		ch->armor[i]		= 100;\n	ch->position		= POS_STANDING;\n	ch->hit			= 20;\n	ch->max_hit			= 20;\n	ch->mana			= 100;\n	ch->max_mana		= 100;\n	ch->move			= 100;\n	ch->max_move		= 100;\n	ch->on			= NULL;\n	for (i = 0; i < MAX_STATS; i ++)\n	{\n	ch->perm_stat[i] = 13; \n	ch->mod_stat[i] = 0;\n	}\n	return;\n}\n\n/*\n * Get an extra description from a list.\n */\nchar *get_extra_descr( const char *name, EXTRA_DESCR_DATA *ed )\n{\n	for ( ; ed != NULL; ed = ed->next )\n	{\n	if ( is_name( (char *) name, ed->keyword ) )\n		return ed->description;\n	}\n	return NULL;\n}\n\n\n\n/*\n * Translates mob virtual number to its mob index struct.\n * Hash table lookup.\n */\nMOB_INDEX_DATA *get_mob_index( int vnum )\n{\n	MOB_INDEX_DATA *pMobIndex;\n\n	for ( pMobIndex  = mob_index_hash[vnum % MAX_KEY_HASH];\n	  pMobIndex != NULL;\n	  pMobIndex  = pMobIndex->next )\n	{\n	if ( pMobIndex->vnum == vnum )\n		return pMobIndex;\n	}\n\n	if ( fBootDb )\n	{\n	bug( \"Get_mob_index: bad vnum %d.\", vnum );\n	exit( 1 );\n	}\n\n	return NULL;\n}\n\n\n\n/*\n * Translates mob virtual number to its obj index struct.\n * Hash table lookup.\n */\nOBJ_INDEX_DATA *get_obj_index( int vnum )\n{\n	OBJ_INDEX_DATA *pObjIndex;\n\n	for ( pObjIndex  = obj_index_hash[vnum % MAX_KEY_HASH];\n	  pObjIndex != NULL;\n	  pObjIndex  = pObjIndex->next )\n	{\n	if ( pObjIndex->vnum == vnum )\n		return pObjIndex;\n	}\n\n	if ( fBootDb )\n	{\n	bug( \"Get_obj_index: bad vnum %d.\", vnum );\n	exit( 1 );\n	}\n\n	return NULL;\n}\n\n\n\n/*\n * Translates mob virtual number to its room index struct.\n * Hash table lookup.\n */\nROOM_INDEX_DATA *get_room_index( int vnum )\n{\n	ROOM_INDEX_DATA *pRoomIndex;\n\n	for ( pRoomIndex  = room_index_hash[vnum % MAX_KEY_HASH];\n	  pRoomIndex != NULL;\n	  pRoomIndex  = pRoomIndex->next )\n	{\n	if ( pRoomIndex->vnum == vnum )\n		return pRoomIndex;\n	}\n\n	if ( fBootDb )\n	{\n	bug( \"Get_room_index: bad vnum %d.\", vnum );\n	exit( 1 );\n	}\n\n	return NULL;\n}\n\nMPROG_CODE *get_mprog_index( int vnum )\n{\n	MPROG_CODE *prg;\n	for( prg = mprog_list; prg; prg = prg->next )\n	{\n		if ( prg->vnum == vnum )\n			return( prg );\n	}\n	return NULL;\n}    \n\n\n\n/*\n * Read a letter from a file.\n */\nchar fread_letter( FILE *fp )\n{\n	char c;\n\n	do\n	{\n	c = getc( fp );\n	}\n	while ( isspace(c) );\n\n	return c;\n}\n\n\n\n/*\n * Read a number from a file.\n */\nint fread_number( FILE *fp )\n{\n	int number;\n	bool sign;\n	char c;\n\n	do\n	{\n	c = getc( fp );\n	}\n	while ( isspace(c) );\n\n	number = 0;\n\n	sign   = FALSE;\n	if ( c == '+' )\n	{\n	c = getc( fp );\n	}\n	else if ( c == '-' )\n	{\n	sign = TRUE;\n	c = getc( fp );\n	}\n\n	if ( !isdigit(c) )\n	{\n	bug( \"Fread_number: bad format.\", 0 );\n	exit( 1 );\n	}\n\n	while ( isdigit(c) )\n	{\n	number = number * 10 + c - '0';\n	c      = getc( fp );\n	}\n\n	if ( sign )\n	number = 0 - number;\n\n	if ( c == '|' )\n	number += fread_number( fp );\n	else if ( c != ' ' )\n	ungetc( c, fp );\n\n	return number;\n}\n\nlong fread_flag( FILE *fp)\n{\n	int number;\n	char c;\n	bool negative = FALSE;\n\n	do\n	{\n	c = getc(fp);\n	}\n	while ( isspace(c));\n\n	if (c == '-')\n	{\n	negative = TRUE;\n	c = getc(fp);\n	}\n\n	number = 0;\n\n	if (!isdigit(c))\n	{\n	while (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))\n	{\n		number += flag_convert(c);\n		c = getc(fp);\n	}\n	}\n\n	while (isdigit(c))\n	{\n	number = number * 10 + c - '0';\n	c = getc(fp);\n	}\n\n	if (c == '|')\n	number += fread_flag(fp);\n\n	else if  ( c != ' ')\n	ungetc(c,fp);\n\n	if (negative)\n	return -1 * number;\n\n	return number;\n}\n\nlong flag_convert(char letter )\n{\n	long bitsum = 0;\n	char i;\n\n	if ('A' <= letter && letter <= 'Z') \n	{\n	bitsum = 1;\n	for (i = letter; i > 'A'; i--)\n		bitsum *= 2;\n	}\n	else if ('a' <= letter && letter <= 'z')\n	{\n	bitsum = 67108864; /* 2^26 */\n	for (i = letter; i > 'a'; i --)\n		bitsum *= 2;\n	}\n\n	return bitsum;\n}\n\n\n\n\n/*\n * Read and allocate space for a string from a file.\n * These strings are read-only and shared.\n * Strings are hashed:\n *   each string prepended with hash pointer to prev string,\n *   hash code is simply the string length.\n *   this function takes 40% to 50% of boot-up time.\n */\nchar *fread_string( FILE *fp )\n{\n	char *plast;\n	char c;\n\n	plast = top_string + sizeof(char *);\n	if ( plast > &string_space[MAX_STRING - MAX_STRING_LENGTH] )\n	{\n	bug( \"Fread_string: MAX_STRING %d exceeded.\", MAX_STRING );\n	exit( 1 );\n	}\n\n	/*\n	 * Skip blanks.\n	 * Read first char.\n	 */\n	do\n	{\n	c = getc( fp );\n	}\n	while ( isspace(c) );\n\n	if ( ( *plast++ = c ) == '~' )\n	return &str_empty[0];\n\n	for ( ;; )\n	{\n		/*\n		 * Back off the char type lookup,\n		 *   it was too dirty for portability.\n		 *   -- Furey\n		 */\n\n	switch ( *plast = getc(fp) )\n	{\n		default:\n			plast++;\n			break;\n \n		case EOF:\n	/* temp fix */\n			bug( \"Fread_string: EOF\", 0 );\n		return NULL;\n			/* exit( 1 ); */\n			break;\n \n		case '\\n':\n			plast++;\n			*plast++ = '\\r';\n			break;\n \n		case '\\r':\n			break;\n \n		case '~':\n			plast++;\n		{\n		union\n		{\n			char *	pc;\n			char	rgc[sizeof(char *)];\n		} u1;\n		int ic;\n		int iHash;\n		char *pHash;\n		char *pHashPrev;\n		char *pString;\n\n		plast[-1] = '\\0';\n		iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );\n		for ( pHash = string_hash[iHash]; pHash; pHash = pHashPrev )\n		{\n			for ( ic = 0; ic < sizeof(char *); ic++ )\n			u1.rgc[ic] = pHash[ic];\n			pHashPrev = u1.pc;\n			pHash    += sizeof(char *);\n\n			if ( top_string[sizeof(char *)] == pHash[0]\n			&&   !strcmp( top_string+sizeof(char *)+1, pHash+1 ) )\n			return pHash;\n		}\n\n		if ( fBootDb )\n		{\n			pString		= top_string;\n			top_string		= plast;\n			u1.pc		= string_hash[iHash];\n			for ( ic = 0; ic < sizeof(char *); ic++ )\n			pString[ic] = u1.rgc[ic];\n			string_hash[iHash]	= pString;\n\n			nAllocString += 1;\n			sAllocString += top_string - pString;\n			return pString + sizeof(char *);\n		}\n		else\n		{\n			return str_dup( top_string + sizeof(char *) );\n		}\n		}\n	}\n	}\n}\n\nchar *fread_string_eol( FILE *fp )\n{\n	static bool char_special[256-EOF];\n	char *plast;\n	char c;\n \n	if ( char_special[EOF-EOF] != TRUE )\n	{\n		char_special[EOF -  EOF] = TRUE;\n		char_special['\\n' - EOF] = TRUE;\n		char_special['\\r' - EOF] = TRUE;\n	}\n \n	plast = top_string + sizeof(char *);\n	if ( plast > &string_space[MAX_STRING - MAX_STRING_LENGTH] )\n	{\n		bug( \"Fread_string: MAX_STRING %d exceeded.\", MAX_STRING );\n		exit( 1 );\n	}\n \n	/*\n	 * Skip blanks.\n	 * Read first char.\n	 */\n	do\n	{\n		c = getc( fp );\n	}\n	while ( isspace(c) );\n \n	if ( ( *plast++ = c ) == '\\n')\n		return &str_empty[0];\n \n	for ( ;; )\n	{\n		if ( !char_special[ ( *plast++ = getc( fp ) ) - EOF ] )\n			continue;\n \n		switch ( plast[-1] )\n		{\n		default:\n			break;\n \n		case EOF:\n			bug( \"Fread_string_eol  EOF\", 0 );\n			exit( 1 );\n			break;\n \n		case '\\n':  case '\\r':\n			{\n				union\n				{\n					char *      pc;\n					char        rgc[sizeof(char *)];\n				} u1;\n				int ic;\n				int iHash;\n				char *pHash;\n				char *pHashPrev;\n				char *pString;\n \n				plast[-1] = '\\0';\n				iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );\n				for ( pHash = string_hash[iHash]; pHash; pHash = pHashPrev )\n				{\n					for ( ic = 0; ic < sizeof(char *); ic++ )\n						u1.rgc[ic] = pHash[ic];\n					pHashPrev = u1.pc;\n					pHash    += sizeof(char *);\n \n					if ( top_string[sizeof(char *)] == pHash[0]\n					&&   !strcmp( top_string+sizeof(char *)+1, pHash+1 ) )\n						return pHash;\n				}\n \n				if ( fBootDb )\n				{\n					pString             = top_string;\n					top_string          = plast;\n					u1.pc               = string_hash[iHash];\n					for ( ic = 0; ic < sizeof(char *); ic++ )\n						pString[ic] = u1.rgc[ic];\n					string_hash[iHash]  = pString;\n \n					nAllocString += 1;\n					sAllocString += top_string - pString;\n					return pString + sizeof(char *);\n				}\n				else\n				{\n					return str_dup( top_string + sizeof(char *) );\n				}\n			}\n		}\n	}\n}\n\n\n\n/*\n * Read to end of line (for comments).\n */\nvoid fread_to_eol( FILE *fp )\n{\n	char c;\n\n	do\n	{\n	c = getc( fp );\n	}\n	while ( c != '\\n' && c != '\\r' );\n\n	do\n	{\n	c = getc( fp );\n	}\n	while ( c == '\\n' || c == '\\r' );\n\n	ungetc( c, fp );\n	return;\n}\n\n\n\n/*\n * Read one word (into static buffer).\n */\nchar *fread_word( FILE *fp )\n{\n	static char word[MAX_INPUT_LENGTH];\n	char *pword;\n	char cEnd;\n\n	do\n	{\n	cEnd = getc( fp );\n	}\n	while ( isspace( cEnd ) );\n\n	if ( cEnd == '\\'' || cEnd == '\"' )\n	{\n	pword   = word;\n	}\n	else\n	{\n	word[0] = cEnd;\n	pword   = word+1;\n	cEnd    = ' ';\n	}\n\n	for ( ; pword < word + MAX_INPUT_LENGTH; pword++ )\n	{\n	*pword = getc( fp );\n	if ( cEnd == ' ' ? isspace(*pword) : *pword == cEnd )\n	{\n		if ( cEnd == ' ' )\n		ungetc( *pword, fp );\n		*pword = '\\0';\n		return word;\n	}\n	}\n\n	bug( \"Fread_word: word too long.\", 0 );\n	exit( 1 );\n	return NULL;\n}\n\n/*\n * Allocate some ordinary memory,\n *   with the expectation of freeing it someday.\n */\nvoid *alloc_mem( int sMem )\n{\n	void *pMem;\n	int *magic;\n	int iList;\n\n	sMem += sizeof(*magic);\n\n	for ( iList = 0; iList < MAX_MEM_LIST; iList++ )\n	{\n		if ( sMem <= rgSizeList[iList] )\n			break;\n	}\n\n	if ( iList == MAX_MEM_LIST )\n	{\n		bug( \"Alloc_mem: size %d too large.\", sMem );\n		exit( 1 );\n	}\n\n	if ( rgFreeList[iList] == NULL )\n	{\n		pMem              = alloc_perm( rgSizeList[iList] );\n	}\n	else\n	{\n		pMem              = rgFreeList[iList];\n		rgFreeList[iList] = * ((void **) rgFreeList[iList]);\n	}\n\n	magic = (int *) pMem;\n	*magic = MAGIC_NUM;\n	pMem += sizeof(*magic);\n\n	return pMem;\n}\n\n\n\n/*\n * Free some memory.\n * Recycle it back onto the free list for blocks of that size.\n */\nvoid free_mem( void *pMem, int sMem )\n{\n	int iList;\n	int *magic;\n\n	pMem -= sizeof(*magic);\n	magic = (int *) pMem;\n\n	if (*magic != MAGIC_NUM)\n	{\n		bug(\"Attempt to recyle invalid memory of size %d.\",sMem);\n		bug((char*) pMem + sizeof(*magic),0);\n		return;\n	}\n\n	*magic = 0;\n	sMem += sizeof(*magic);\n\n	for ( iList = 0; iList < MAX_MEM_LIST; iList++ )\n	{\n		if ( sMem <= rgSizeList[iList] )\n			break;\n	}\n\n	if ( iList == MAX_MEM_LIST )\n	{\n		bug( \"Free_mem: size %d too large.\", sMem );\n		exit( 1 );\n	}\n\n	* ((void **) pMem) = rgFreeList[iList];\n	rgFreeList[iList]  = pMem;\n\n	return;\n}\n\n\n/*\n * Allocate some permanent memory.\n * Permanent memory is never freed,\n *   pointers into it may be copied safely.\n */\nvoid *alloc_perm( int sMem )\n{\n	static char *pMemPerm;\n	static int iMemPerm;\n	void *pMem;\n\n	while ( sMem % sizeof(long) != 0 )\n	sMem++;\n	if ( sMem > MAX_PERM_BLOCK )\n	{\n	bug( \"Alloc_perm: %d too large.\", sMem );\n	exit( 1 );\n	}\n\n	if ( pMemPerm == NULL || iMemPerm + sMem > MAX_PERM_BLOCK )\n	{\n	iMemPerm = 0;\n	if ( ( pMemPerm = calloc( 1, MAX_PERM_BLOCK ) ) == NULL )\n	{\n		perror( \"Alloc_perm\" );\n		exit( 1 );\n	}\n	}\n\n	pMem        = pMemPerm + iMemPerm;\n	iMemPerm   += sMem;\n	nAllocPerm += 1;\n	sAllocPerm += sMem;\n	return pMem;\n}\n\n\nvoid do_areas( CHAR_DATA *ch, char *argument )\n{\n	char buf[MAX_STRING_LENGTH];\n	AREA_DATA *pArea1;\n	AREA_DATA *pArea2;\n	int iArea;\n	int iAreaHalf;\n\n	if (argument[0] != '\\0')\n	{\n	send_to_char(\"No argument is used with this command.\\n\\r\",ch);\n	return;\n	}\n\n	iAreaHalf = (top_area + 1) / 2;\n	pArea1    = area_first;\n	pArea2    = area_first;\n	for ( iArea = 0; iArea < iAreaHalf; iArea++ )\n	pArea2 = pArea2->next;\n\n	for ( iArea = 0; iArea < iAreaHalf; iArea++ )\n	{\n	sprintf( buf, \"%-39s%-39s\\n\\r\",\n		pArea1->credits, (pArea2 != NULL) ? pArea2->credits : \"\" );\n	send_to_char( buf, ch );\n	pArea1 = pArea1->next;\n	if ( pArea2 != NULL )\n		pArea2 = pArea2->next;\n	}\n\n	return;\n}\n\n\n\nvoid do_memory( CHAR_DATA *ch, char *argument )\n{\n	char buf[MAX_STRING_LENGTH];\n\n	sprintf( buf, \"Affects %5d\\n\\r\", top_affect    ); send_to_char( buf, ch );\n	sprintf( buf, \"Areas   %5d\\n\\r\", top_area      ); send_to_char( buf, ch );\n	sprintf( buf, \"ExDes   %5d\\n\\r\", top_ed        ); send_to_char( buf, ch );\n	sprintf( buf, \"Exits   %5d\\n\\r\", top_exit      ); send_to_char( buf, ch );\n	sprintf( buf, \"Helps   %5d\\n\\r\", top_help      ); send_to_char( buf, ch );\n	sprintf( buf, \"Socials %5d\\n\\r\", social_count  ); send_to_char( buf, ch );\n	sprintf( buf, \"Mobs    %5d(%d new format)\\n\\r\", top_mob_index,newmobs ); \n	send_to_char( buf, ch );\n	sprintf( buf, \"(in use)%5d\\n\\r\", mobile_count  ); send_to_char( buf, ch );\n	sprintf( buf, \"Objs    %5d(%d new format)\\n\\r\", top_obj_index,newobjs ); \n	send_to_char( buf, ch );\n	sprintf( buf, \"Resets  %5d\\n\\r\", top_reset     ); send_to_char( buf, ch );\n	sprintf( buf, \"Rooms   %5d\\n\\r\", top_room      ); send_to_char( buf, ch );\n	sprintf( buf, \"Shops   %5d\\n\\r\", top_shop      ); send_to_char( buf, ch );\n\n	sprintf( buf, \"Strings %5d strings of %7d bytes (max %d).\\n\\r\",\n	nAllocString, sAllocString, MAX_STRING );\n	send_to_char( buf, ch );\n\n	sprintf( buf, \"Perms   %5d blocks  of %7d bytes.\\n\\r\",\n	nAllocPerm, sAllocPerm );\n	send_to_char( buf, ch );\n\n	return;\n}\n\nvoid do_dump( CHAR_DATA *ch, char *argument )\n{\n	int count,count2,num_pcs,aff_count;\n	CHAR_DATA *fch;\n	MOB_INDEX_DATA *pMobIndex;\n	PC_DATA *pc;\n	OBJ_DATA *obj;\n	OBJ_INDEX_DATA *pObjIndex;\n	ROOM_INDEX_DATA *room;\n	EXIT_DATA *exit;\n	DESCRIPTOR_DATA *d;\n	AFFECT_DATA *af;\n	FILE *fp;\n	int vnum,nMatch = 0;\n\n	/* open file */\n	fclose(fpReserve);\n	fp = fopen(\"mem.dmp\",\"w\");\n\n	/* report use of data structures */\n	\n	num_pcs = 0;\n	aff_count = 0;\n\n	/* mobile prototypes */\n	fprintf(fp,\"MobProt	%4d (%8zd bytes)\\n\",\n	top_mob_index, top_mob_index * (sizeof(*pMobIndex))); \n\n	/* mobs */\n	count = 0;  count2 = 0;\n	for (fch = char_list; fch != NULL; fch = fch->next)\n	{\n	count++;\n	if (fch->pcdata != NULL)\n		num_pcs++;\n	for (af = fch->affected; af != NULL; af = af->next)\n		aff_count++;\n	}\n	for (fch = char_free; fch != NULL; fch = fch->next)\n	count2++;\n\n	fprintf(fp,\"Mobs	%4d (%8zd bytes), %2d free (%zd bytes)\\n\",\n	count, count * (sizeof(*fch)), count2, count2 * (sizeof(*fch)));\n\n	/* pcdata */\n	count = 0;\n	for (pc = pcdata_free; pc != NULL; pc = pc->next)\n	count++; \n\n	fprintf(fp,\"Pcdata	%4d (%8zd bytes), %2d free (%zd bytes)\\n\",\n	num_pcs, num_pcs * (sizeof(*pc)), count, count * (sizeof(*pc)));\n\n	/* descriptors */\n	count = 0; count2 = 0;\n	for (d = descriptor_list; d != NULL; d = d->next)\n	count++;\n	for (d= descriptor_free; d != NULL; d = d->next)\n	count2++;\n\n	fprintf(fp, \"Descs	%4d (%8zd bytes), %2d free (%zd bytes)\\n\",\n	count, count * (sizeof(*d)), count2, count2 * (sizeof(*d)));\n\n	/* object prototypes */\n	for ( vnum = 0; nMatch < top_obj_index; vnum++ )\n		if ( ( pObjIndex = get_obj_index( vnum ) ) != NULL )\n		{\n		for (af = pObjIndex->affected; af != NULL; af = af->next)\n		aff_count++;\n			nMatch++;\n		}\n\n	fprintf(fp,\"ObjProt	%4d (%8zd bytes)\\n\",\n	top_obj_index, top_obj_index * (sizeof(*pObjIndex)));\n\n\n	/* objects */\n	count = 0;  count2 = 0;\n	for (obj = object_list; obj != NULL; obj = obj->next)\n	{\n	count++;\n	for (af = obj->affected; af != NULL; af = af->next)\n		aff_count++;\n	}\n	for (obj = obj_free; obj != NULL; obj = obj->next)\n	count2++;\n\n	fprintf(fp,\"Objs	%4d (%8zd bytes), %2d free (%zd bytes)\\n\",\n	count, count * (sizeof(*obj)), count2, count2 * (sizeof(*obj)));\n\n	/* affects */\n	count = 0;\n	for (af = affect_free; af != NULL; af = af->next)\n	count++;\n\n	fprintf(fp,\"Affects	%4d (%8zd bytes), %2d free (%zd bytes)\\n\",\n	aff_count, aff_count * (sizeof(*af)), count, count * (sizeof(*af)));\n\n	/* rooms */\n	fprintf(fp,\"Rooms	%4d (%8zd bytes)\\n\",\n	top_room, top_room * (sizeof(*room)));\n\n	 /* exits */\n	fprintf(fp,\"Exits	%4d (%8zd bytes)\\n\",\n	top_exit, top_exit * (sizeof(*exit)));\n\n	fclose(fp);\n\n	/* start printing out mobile data */\n	fp = fopen(\"mob.dmp\",\"w\");\n\n	fprintf(fp,\"\\nMobile Analysis\\n\");\n	fprintf(fp,  \"---------------\\n\");\n	nMatch = 0;\n	for (vnum = 0; nMatch < top_mob_index; vnum++)\n	if ((pMobIndex = get_mob_index(vnum)) != NULL)\n	{\n		nMatch++;\n		fprintf(fp,\"#%-4d %3d active %3d killed     %s\\n\",\n		pMobIndex->vnum,pMobIndex->count,\n		pMobIndex->killed,pMobIndex->short_descr);\n	}\n	fclose(fp);\n\n	/* start printing out object data */\n	fp = fopen(\"obj.dmp\",\"w\");\n\n	fprintf(fp,\"\\nObject Analysis\\n\");\n	fprintf(fp,  \"---------------\\n\");\n	nMatch = 0;\n	for (vnum = 0; nMatch < top_obj_index; vnum++)\n	if ((pObjIndex = get_obj_index(vnum)) != NULL)\n	{\n		nMatch++;\n		fprintf(fp,\"#%-4d %3d active %3d reset      %s\\n\",\n		pObjIndex->vnum,pObjIndex->count,\n		pObjIndex->reset_num,pObjIndex->short_descr);\n	}\n\n	/* close file */\n	fclose(fp);\n	fpReserve = fopen( NULL_FILE, \"r\" );\n}\n\n\n\n/*\n * Stick a little fuzz on a number.\n */\nint number_fuzzy( int number )\n{\n	switch ( number_bits( 2 ) )\n	{\n	case 0:  number -= 1; break;\n	case 3:  number += 1; break;\n	}\n\n	return UMAX( 1, number );\n}\n\n\n\n/*\n * Generate a random number.\n */\nint number_range( int from, int to )\n{\n	int power;\n	int number;\n\n	if (from == 0 && to == 0)\n	return 0;\n\n	if ( ( to = to - from + 1 ) <= 1 )\n	return from;\n\n	for ( power = 2; power < to; power <<= 1 )\n	;\n\n	while ( ( number = number_mm() & (power -1 ) ) >= to )\n	;\n\n	return from + number;\n}\n\n\n\n/*\n * Generate a percentile roll.\n */\nint number_percent( void )\n{\n	int percent;\n\n	while ( (percent = number_mm() & (128-1) ) > 99 )\n	;\n\n	return 1 + percent;\n}\n\n\n\n/*\n * Generate a random door.\n */\nint number_door( void )\n{\n	int door;\n\n	while ( ( door = number_mm() & (8-1) ) > 5)\n	;\n\n	return door;\n}\n\nint number_bits( int width )\n{\n	return number_mm( ) & ( ( 1 << width ) - 1 );\n}\n\n\n\n\n/*\n * I've gotten too many bad reports on OS-supplied random number generators.\n * This is the Mitchell-Moore algorithm from Knuth Volume II.\n * Best to leave the constants alone unless you've read Knuth.\n * -- Furey\n */\n\n/* I noticed streaking with this random number generator, so I switched\n   back to the system srandom call.  If this doesn't work for you, \n   define OLD_RAND to use the old system -- Alander */\n\n#if defined (OLD_RAND)\nstatic  int     rgiState[2+55];\n#endif\n \nvoid init_mm( )\n{\n#if defined (OLD_RAND)\n	int *piState;\n	int iState;\n \n	piState     = &rgiState[2];\n \n	piState[-2] = 55 - 55;\n	piState[-1] = 55 - 24;\n \n	piState[0]  = ((int) current_time) & ((1 << 30) - 1);\n	piState[1]  = 1;\n	for ( iState = 2; iState < 55; iState++ )\n	{\n		piState[iState] = (piState[iState-1] + piState[iState-2])\n						& ((1 << 30) - 1);\n	}\n#else\n	srandom(time(NULL)^getpid());\n#endif\n	return;\n}\n \n \n \nlong number_mm( void )\n{\n#if defined (OLD_RAND)\n	int *piState;\n	int iState1;\n	int iState2;\n	int iRand;\n \n	piState             = &rgiState[2];\n	iState1             = piState[-2];\n	iState2             = piState[-1];\n	iRand               = (piState[iState1] + piState[iState2])\n						& ((1 << 30) - 1);\n	piState[iState1]    = iRand;\n	if ( ++iState1 == 55 )\n		iState1 = 0;\n	if ( ++iState2 == 55 )\n		iState2 = 0;\n	piState[-2]         = iState1;\n	piState[-1]         = iState2;\n	return iRand >> 6;\n#else\n	return random() >> 6;\n#endif\n}\n\n\n/*\n * Roll some dice.\n */\nint dice( int number, int size )\n{\n	int idice;\n	int sum;\n\n	switch ( size )\n	{\n	case 0: return 0;\n	case 1: return number;\n	}\n\n	for ( idice = 0, sum = 0; idice < number; idice++ )\n	sum += number_range( 1, size );\n\n	return sum;\n}\n\n\n\n/*\n * Simple linear interpolation.\n */\nint interpolate( int level, int value_00, int value_32 )\n{\n	return value_00 + level * (value_32 - value_00) / 32;\n}\n\n\n\n/*\n * Removes the tildes from a string.\n * Used for player-entered strings that go into disk files.\n */\nvoid smash_tilde( char *str )\n{\n	for ( ; *str != '\\0'; str++ )\n	{\n	if ( *str == '~' )\n		*str = '-';\n	}\n\n	return;\n}\n\n\n/*\n * Compare strings, case insensitive.\n * Return TRUE if different\n *   (compatibility with historical functions).\n */\nbool __strcmp(const char *astr, const char *bstr, const char *_file, const char *_function, int _line)\n{\n    if ( astr == NULL )\n    {\n        bug( Format(\"str_cmp: null astr from %s, %s %d\",_file,_function, _line), 0 );\n        return TRUE;\n    }\n    if ( bstr == NULL )\n    {\n        bug( Format (\"Str_cmp: null bstr from %s, %s %d\",_file,_function, _line), 0 );\n        return TRUE;\n    }\n    for ( ; *astr || *bstr; astr++, bstr++ )\n    {\n        if ( LOWER(*astr) != LOWER(*bstr) )\n            return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Compare strings, case insensitive, for prefix matching.\n * Return TRUE if astr not a prefix of bstr\n *   (compatibility with historical functions).\n */\nbool str_prefix( const char *astr, const char *bstr )\n{\n	if ( astr == NULL )\n	{\n	bug( \"Strn_cmp: null astr.\", 0 );\n	return TRUE;\n	}\n\n	if ( bstr == NULL )\n	{\n	bug( \"Strn_cmp: null bstr.\", 0 );\n	return TRUE;\n	}\n\n	for ( ; *astr; astr++, bstr++ )\n	{\n	if ( LOWER(*astr) != LOWER(*bstr) )\n		return TRUE;\n	}\n\n	return FALSE;\n}\n\n\n\n/*\n * Compare strings, case insensitive, for match anywhere.\n * Returns TRUE is astr not part of bstr.\n *   (compatibility with historical functions).\n */\nbool str_infix( const char *astr, const char *bstr )\n{\n	int sstr1;\n	int sstr2;\n	int ichar;\n	char c0;\n\n	if ( ( c0 = LOWER(astr[0]) ) == '\\0' )\n	return FALSE;\n\n	sstr1 = strlen(astr);\n	sstr2 = strlen(bstr);\n\n	for ( ichar = 0; ichar <= sstr2 - sstr1; ichar++ )\n	{\n	if ( c0 == LOWER(bstr[ichar]) && !str_prefix( astr, bstr + ichar ) )\n		return FALSE;\n	}\n\n	return TRUE;\n}\n\n\n\n/*\n * Compare strings, case insensitive, for suffix matching.\n * Return TRUE if astr not a suffix of bstr\n *   (compatibility with historical functions).\n */\nbool str_suffix( const char *astr, const char *bstr )\n{\n	int sstr1;\n	int sstr2;\n\n	sstr1 = strlen(astr);\n	sstr2 = strlen(bstr);\n	if ( sstr1 <= sstr2 && !str_cmp( astr, bstr + sstr2 - sstr1 ) )\n	return FALSE;\n	else\n	return TRUE;\n}\n\n\n\n/*\n * Returns an initial-capped string.\n */\nchar *capitalize( const char *str )\n{\n	static char strcap[MAX_STRING_LENGTH];\n	int i;\n\n	for ( i = 0; str[i] != '\\0'; i++ )\n	strcap[i] = LOWER(str[i]);\n	strcap[i] = '\\0';\n	strcap[0] = UPPER(strcap[0]);\n	return strcap;\n}\n\n\n/*\n * Append a string to a file.\n */\nvoid append_file( CHAR_DATA *ch, char *file, char *str )\n{\n	FILE *fp;\n\n	if ( IS_NPC(ch) || str[0] == '\\0' )\n	return;\n\n	fclose( fpReserve );\n	if ( ( fp = fopen( file, \"a\" ) ) == NULL )\n	{\n	perror( file );\n	send_to_char( \"Could not open the file!\\n\\r\", ch );\n	}\n	else\n	{\n	fprintf( fp, \"[%5d] %s: %s\\n\",\n		ch->in_room ? ch->in_room->vnum : 0, ch->name, str );\n	fclose( fp );\n	}\n\n	fpReserve = fopen( NULL_FILE, \"r\" );\n	return;\n}\n\n\n\n/*\n * Reports a bug.\n */\nvoid bug( const char *str, int param )\n{\n	char buf[MAX_STRING_LENGTH];\n\n	if ( fpArea != NULL )\n	{\n	int iLine;\n	int iChar;\n\n	if ( fpArea == stdin )\n	{\n		iLine = 0;\n	}\n	else\n	{\n		iChar = ftell( fpArea );\n		fseek( fpArea, 0, 0 );\n		for ( iLine = 0; ftell( fpArea ) < iChar; iLine++ )\n		{\n		while ( getc( fpArea ) != '\\n' )\n			;\n		}\n		fseek( fpArea, iChar, 0 );\n	}\n\n	sprintf( buf, \"[*****] FILE: %s LINE: %d\", strArea, iLine );\n	log_string( buf );\n/* RT removed because we don't want bugs shutting the mud \n	if ( ( fp = fopen( \"shutdown.txt\", \"a\" ) ) != NULL )\n	{\n		fprintf( fp, \"[*****] %s\\n\", buf );\n		fclose( fp );\n	}\n*/\n	}\n\n	strcpy( buf, \"[*****] BUG: \" );\n	sprintf( buf + strlen(buf), str, param );\n	log_string( buf );\n/* RT removed due to bug-file spamming \n	fclose( fpReserve );\n	if ( ( fp = fopen( BUG_FILE, \"a\" ) ) != NULL )\n	{\n	fprintf( fp, \"%s\\n\", buf );\n	fclose( fp );\n	}\n	fpReserve = fopen( NULL_FILE, \"r\" );\n*/\n\n	return;\n}\n\n\n\n/*\n * Writes a string to the log.\n */\nvoid log_string( const char *str )\n{\n	char *strtime;\n\n	strtime                    = ctime( &current_time );\n	strtime[strlen(strtime)-1] = '\\0';\n	fprintf( stderr, \"%s :: %s\\n\", strtime, str );\n	return;\n}\n\n\n\n/*\n * This function is here to aid in debugging.\n * If the last expression in a function is another function call,\n *   gcc likes to generate a JMP instead of a CALL.\n * This is called \"tail chaining.\"\n * It hoses the debugger call stack for that call.\n * So I make this the last call in certain critical functions,\n *   where I really need the call stack to be right for debugging!\n *\n * If you don't understand this, then LEAVE IT ALONE.\n * Don't remove any calls to tail_chain anywhere.\n *\n * -- Furey\n */\nvoid tail_chain( void )\n{\n	return;\n}\n\n// Improved strdup capabilitys for logging / debugging by David Simmerson\nchar *_str_dup(const char *str, const char *file, const char *function, int line)\n{\n    if(IS_NULLSTR(str))\n    {\n        log_string(Format(\"_str_dup: %s:%s:%d called with NULL values!\", file, function, line ) );\n        return NULL;\n    }\n    return strdup(str);  // relay to our actual strdup!\n}\n\n// Format by David Simmerson\nconst char *Format(const char *fmt, ...)\n{\n\n    static char textString[MSL*5] = {'\\0'};\n\n    // -- empty the buffer properly to ensure no leaks.\n    memset(textString, '\\0', sizeof(textString));\n\n    va_list args;\n    va_start ( args, fmt );\n    int length = vsnprintf ( textString, MSL*5, fmt, args );\n    va_end ( args );\n\n    if(length == 0) {\n        log_string(\"Format had a boo-boo! 0 length string returned!  Suspect will cause corruption and/or crash!\");\n    }\n\n    return textString;\n}\n\n// CapitalSentence by David Simmerson\nchar *CapitalSentence(const char *str)\n{\n    static char _buf[MSL*5]={'\\0'};\n    bool didPeriod= false;\n    memset(_buf, 0, sizeof(_buf));\n    int _x = 0;\n    for(_x = 0; str[_x] != '\\0'; _x++)\n    {\n        if(_x == 0) // first letter of the string is capitalized.\n            _buf[0] = UPPER(str[0]);\n        else\n        {\n            if(str[_x] == '.')\n            {\n                _buf[_x] = str[_x];\n                didPeriod = true;\n                continue;\n            }\n            // are we a letter that needs to be capitalized.\n            if(didPeriod && isalpha(str[_x]))\n            {\n                _buf[_x] = UPPER(str[_x]);\n                didPeriod = false;\n                continue;\n            }\n            // just a letter/number/etc, push it to the new buffer.\n            _buf[_x] = str[_x];\n        }\n    }\n    return (_buf);\n}\n\n#ifdef ASSERT\nvoid AssertLog(const std::string &str) {\n        closeReserve();\nFILE *fp = fopen(\"Assert.log\", \"a\");\nif(fp) {\nfprintf(fp, \"%s\\n\", str );\n} else {\n                fprintf(stdout, \"%s\\n\", str);\n}\nfclose(fp); // just in-case.\n        openReserve();\n}\nvoid AssertFailed ( const char *expression, const char *msg, const char *file, const char *baseFile, const char *function, int line )\n{\nif ( !str_cmp ( file, baseFile ) ) {\nAssertLog(Format(\"Assert(%s)(%s) failed in file(%s), function(%s), line(%d)\", expression, msg, file, function.c_str(), line ) );\n} else {\nAssertLog(Format(\"Assert(%s)(%s) failed in file(%s), included from file(%s), function(%s), line(%d)\", expression, msg, file, baseFile, function, line ) );\n}\n// what this does: if ASSERT_CRASH is defined, we let the assert log, THEN continue! as if nothing bad is about to happen!\n// then we crash at the actual instance so we can get ourselves a nice core-file!\n// however, if ASSERT_CRASH is not defined, we will ABORT and simply log.\n// Note: some systems will leave a crash-log when aborting (dump core file)\n#if !defined (ASSERT_CRASH)\n// if REAL_ASSERT is defined we skip the abort because it will assert the expression (double logging, we know)\n// but it gives us a great opportunity to check out differences in results.  As well as create a new standard\n// to hold the code to.\n#if !defined(REAL_ASSERT)\nabort();\n#endif\n#endif\n}\n#endif\n\nvoid openReserve(void)\n{\n    if(fpReserve) return;\n    if ((fpReserve = fopen (NULL_FILE, \"r\")) == NULL)\n    {\n        perror (Format(\"%s : %s\", __FUNCTION__, NULL_FILE ) );\n        exit (1);\n    }\n}\nvoid closeReserve(void)\n{\n    if(fpReserve)\n    {\n          fclose(fpReserve);\n    }\n    fpReserve = NULL;\n}\n",
			"file": "src/db.c",
			"file_size": 88312,
			"file_write_time": 130093944878691210,
			"settings":
			{
				"buffer_size": 84105,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"",
				"Indentation: Reindent Lines"
			]
		],
		"width": 392.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/merc.h",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/string.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/save.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/recycle.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/olc_act.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/note.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/mem.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/magic.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/hedit.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/handler.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/fight.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/comm.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/alias.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/act_wiz.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/act_obj.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/act_info.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/db.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/interp.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/olc_save.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/mob_prog.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/const.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/tables.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/protocol.h",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/magic2.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/update.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/Makefile",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/protocol.c",
		"/C/Users/valpo/Documents/GitHub/dungeonworld/src/scan.c",
		"/E/Brandon/Course_Development/aemud/src/Makefile",
		"/E/Brandon/Course_Development/aemud/src/tables.h",
		"/E/Brandon/Course_Development/aemud/src/tables.h.rej",
		"/E/Brandon/Course_Development/aemud/src/Makefile.rej",
		"/E/Brandon/Course_Development/aemud/src/comm.c",
		"/E/Brandon/Course_Development/aemud/src/alias.c",
		"/E/Brandon/Course_Development/aemud/src/ban.c",
		"/E/Brandon/Course_Development/aemud/src/bit.c",
		"/E/Brandon/Course_Development/aemud/src/board.c",
		"/E/Brandon/Course_Development/aemud/src/const.c",
		"/E/Brandon/Course_Development/aemud/src/db2.c",
		"/E/Brandon/Course_Development/aemud/src/db.c",
		"/E/Brandon/Course_Development/aemud/src/effects.c",
		"/E/Brandon/Course_Development/aemud/src/flags.c",
		"/E/Brandon/Course_Development/aemud/src/healer.c",
		"/E/Brandon/Course_Development/aemud/src/hedit.c",
		"/E/Brandon/Course_Development/aemud/src/lookup.c",
		"/E/Brandon/Course_Development/aemud/src/mob_cmds.c",
		"/E/Brandon/Course_Development/aemud/src/mob_prog.c",
		"/E/Brandon/Course_Development/aemud/src/music.c",
		"/E/Brandon/Course_Development/aemud/src/olc.c",
		"/E/Brandon/Course_Development/aemud/src/olc_mpcode.c",
		"/E/Brandon/Course_Development/aemud/src/olc_act.c",
		"/E/Brandon/Course_Development/aemud/src/olc_save.c",
		"/E/Brandon/Course_Development/aemud/src/protocol.c",
		"/E/Brandon/Course_Development/aemud/src/wizutil.c",
		"/E/Brandon/Course_Development/aemud/src/recycle.c",
		"/E/Brandon/Course_Development/aemud/src/save.c",
		"/E/Brandon/Course_Development/aemud/src/scan.c",
		"/E/Brandon/Course_Development/aemud/src/string.c",
		"/E/Brandon/Course_Development/aemud/src/wizlist.c",
		"/E/Brandon/Course_Development/aemud/src/update.c",
		"/E/Brandon/Course_Development/aemud/src/special.c",
		"/E/Brandon/Course_Development/aemud/src/skills.c",
		"/E/Brandon/Course_Development/aemud/src/magic2.c",
		"/E/Brandon/Course_Development/aemud/src/magic.c",
		"/E/Brandon/Course_Development/aemud/src/handler.c",
		"/E/Brandon/Course_Development/aemud/src/interp.h",
		"/E/Brandon/Course_Development/aemud/src/act_wiz.c",
		"/E/Brandon/Course_Development/aemud/src/act_obj.c",
		"/E/Brandon/Course_Development/aemud/src/act_move.c",
		"/E/Brandon/Course_Development/aemud/src/act_info.c",
		"/E/Brandon/Course_Development/aemud/src/interp.c",
		"/E/Brandon/Course_Development/aemud/src/act_comm.c",
		"/E/Brandon/Course_Development/aemud/src/act_enter.c",
		"/E/Brandon/Course_Development/aemud/src/fight.c",
		"/E/Brandon/Course_Development/aemud/src/merc.h",
		"/E/Brandon/Course_Development/aemud/src/note.c",
		"/E/Brandon/Course_Development/aemud/src/recycle.h",
		"/E/Brandon/Course_Development/aemud/src/mem.c",
		"/E/Brandon/Course_Development/aemud/src/protocol.h",
		"/E/Brandon/Course_Development/aemud/src/colordef.h",
		"/E/Brandon/Course_Development/aemud/src/merc.h.rej",
		"/E/Brandon/Course_Development/aemud/src/save.c.rej",
		"/E/Brandon/Course_Development/aemud/src/comm.c.rej",
		"/E/Brandon/Course_Development/aemud/src/act_info.c.rej",
		"/E/Brandon/Course_Development/aemud/src/act_comm.c.rej",
		"/E/Brandon/Course_Development/Rom24/src/tables.h",
		"/E/Brandon/Course_Development/Rom24/src/lookup.c",
		"/E/Brandon/Course_Development/Rom24/src/lookup.h",
		"/E/Brandon/Course_Development/Rom24/src/act_info.c",
		"/E/Brandon/Course_Development/Rom24/src/save.c",
		"/E/Brandon/Course_Development/Rom24/src/Makefile.rej",
		"/E/Brandon/Course_Development/Rom24/src/tables.h.rej",
		"/E/Brandon/Course_Development/Rom24/src/merc.h",
		"/E/Brandon/Course_Development/Rom24/src/merc.h.rej",
		"/E/Brandon/Course_Development/Rom24/src/Makefile",
		"/C/Users/bmorris2/AppData/Roaming/Sublime Text 2/Packages/Default/Preferences.sublime-settings",
		"/E/Brandon/Course_Development/ROM/src/Makefile",
		"/E/Brandon/Course_Development/ROM/src/act_comm.c",
		"/E/Brandon/Course_Development/ROM/src/tables.c",
		"/E/Brandon/Course_Development/ROM/src/tables.h",
		"/E/Brandon/Course_Development/ROM/src/interp.h",
		"/E/Brandon/Course_Development/ROM/src/merc.h",
		"/E/Brandon/Course_Development/ROM/src/tables.h.orig",
		"/E/Brandon/Course_Development/ROM/src/tables.h.rej",
		"/E/Brandon/Course_Development/ROM/src/save.c.rej",
		"/E/Brandon/Course_Development/ROM/src/save.c",
		"/E/Brandon/Course_Development/ROM/src/merc.h.orig",
		"/E/Brandon/Course_Development/ROM/src/merc.h.rej",
		"/E/Brandon/Course_Development/ROM/src/update.c.orig",
		"/E/Brandon/Course_Development/ROM/src/interp.h.rej",
		"/E/Brandon/Course_Development/ROM/src/db.c",
		"/E/Brandon/Course_Development/ROM/src/db.c.rej",
		"/E/Brandon/Course_Development/ROM/src/comm.c",
		"/E/Brandon/Course_Development/ROM/src/comm.c.rej",
		"/E/Brandon/Course_Development/ROM/src/act_comm.c.orig",
		"/E/Brandon/Course_Development/ROM/src/Makefile.solaris",
		"/E/Brandon/Course_Development/ROM/src/Makefile.rej",
		"/E/Brandon/Course_Development/ROM/src/recycle.c",
		"/E/Brandon/Course_Development/ROM/src/interp.c",
		"/E/Brandon/Course_Development/ROM/src/recycle.h",
		"/C/Users/bmorris2/AppData/Roaming/Sublime Text 2/Packages/User/Default (Windows).sublime-keymap",
		"/E/Brandon/Course_Development/ROM/src/act_info.c",
		"/E/Brandon/Course_Development/ROM/src/update.c",
		"/E/Brandon/Course_Development/ROM/src/protocol.h",
		"/E/Brandon/Course_Development/ROM/src/protocol.c",
		"/E/Brandon/Course_Development/snippets/protocol/protocol.h",
		"/E/Brandon/Course_Development/snippets/protocol/protocol.c",
		"/E/Brandon/Course_Development/ROM/src/Makefile.linux"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"free_string",
			"free_mem",
			"SKEY",
			"title",
			"str_dup(\"\")",
			"CopyTo",
			"FORM_BIPED",
			"CHK_MONEY",
			"FORM_GIANT",
			"FORM_AMPHIBIAN",
			"FORM_INTANGIBLE",
			"\n\nFORM_INTANGIBLE",
			"variable_t",
			"FORM_BIRD",
			"FORM_WORM",
			"FORM_SPIDER",
			"FORM_MIST",
			"FORM_INSECT",
			"FORM_CENTAUR",
			"FORM_BLOB",
			"FORM_BIPED",
			"FORM_",
			"pcdata->",
			"write_to_buffer( d, echo_on_str, 0 );",
			"d->fcommand",
			"void write_to_buffer",
			"bool read_from_descriptor( DESCRIPTOR_DATA *d )",
			"alloc_mem( dnew->outsize );",
			"descriptor_data",
			"protocol",
			"write_to_buffer",
			"descriptor_data",
			"do_score",
			"[INFO]",
			"do_score",
			"ProtocolCreate",
			"Variable table does not match the enums in the header.",
			"void do_help",
			"main",
			"do_funct",
			"do_function",
			"do_quit",
			"bool is_number",
			"one_argument",
			"multi_hit",
			"multi_hit'",
			"565",
			"{2",
			"ALLOC_PERM",
			"ALLOC_MEM",
			"free_mem",
			"default_colour",
			"free_string",
			"new_buf_size",
			"new_buf",
			"__strcmp",
			"__strcmp'",
			"str_cmp",
			"*buffer_list",
			"BUFFER_list",
			"Strn_cmp",
			"3588",
			"strlen",
			"sprintf",
			"strcpy",
			"str_cpy",
			"strlen",
			"bool strlen",
			"sprintf",
			"void sprintf",
			"str_cmp",
			"pcdata",
			"reboot",
			"BUFFER",
			"new_buf",
			"buf_free",
			"pcdata",
			"EXTRA_DESCR_DATA",
			"do_colour",
			"do_dump",
			"Note",
			"new_help",
			"logfmt",
			"new_area",
			"room",
			"->name",
			"area",
			"Attempt to recyle invalid memory of size ",
			"New Area",
			"BUG: New Area",
			"str_dup",
			"db.c",
			"do_score",
			"write_to_buffer( d, echo_on_str, 0 );",
			"d->fcommand",
			"act( \"$n has entered the game.\", ch, NULL, NULL, TO_ROOM );",
			"2000",
			"200",
			"struct	descriptor_data",
			"GREEN",
			"BOLD",
			"NO_COLOR",
			"NO COLOR",
			"GREEN",
			"NOAUCTION",
			"lookup.h",
			"tables.h",
			"struct flag_type",
			"flag_type",
			"int sex_lookup",
			"struct flag_type",
			"flag_type",
			"recval_table",
			"bit_type",
			"+extern	const	struct	bit_type	bitvector_type[];\n+extern	const	struct	recval_type	recval_table[];\nbit_type",
			"MSL",
			"KEY (\"Shd\"",
			"RID",
			"gen_data",
			"new_gen_data",
			"do_dump",
			"fwrite_char",
			"Attempt to recyle invalid memory",
			"LEVEL",
			"version",
			"VERSION",
			"fwrite_char",
			"IS_NPC"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"ROOM_VNUM_JAIL"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"settings":
					{
						"buffer_size": 97709,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										164,
										175
									],
									[
										319,
										330
									],
									[
										412,
										423
									],
									[
										575,
										586
									],
									[
										772,
										783
									],
									[
										975,
										986
									],
									[
										1184,
										1195
									],
									[
										1309,
										1320
									],
									[
										1557,
										1568
									],
									[
										1754,
										1765
									],
									[
										1931,
										1942
									],
									[
										2071,
										2082
									],
									[
										2236,
										2247
									],
									[
										2354,
										2365
									],
									[
										2537,
										2548
									],
									[
										2728,
										2739
									],
									[
										2914,
										2925
									],
									[
										3114,
										3125
									],
									[
										3281,
										3292
									],
									[
										3461,
										3472
									],
									[
										3632,
										3643
									],
									[
										3793,
										3804
									],
									[
										4003,
										4014
									],
									[
										4259,
										4270
									],
									[
										4309,
										4320
									],
									[
										4527,
										4538
									],
									[
										4722,
										4733
									],
									[
										4971,
										4982
									],
									[
										5164,
										5175
									],
									[
										5322,
										5333
									],
									[
										5485,
										5496
									],
									[
										5625,
										5636
									],
									[
										5918,
										5929
									],
									[
										6213,
										6224
									],
									[
										6489,
										6500
									],
									[
										6683,
										6694
									],
									[
										6886,
										6897
									],
									[
										7078,
										7089
									],
									[
										7117,
										7128
									],
									[
										7161,
										7172
									],
									[
										7204,
										7215
									],
									[
										7363,
										7374
									],
									[
										7405,
										7416
									],
									[
										7550,
										7561
									],
									[
										7589,
										7600
									],
									[
										7635,
										7646
									],
									[
										7778,
										7789
									],
									[
										7816,
										7827
									],
									[
										7861,
										7872
									],
									[
										8042,
										8053
									],
									[
										8087,
										8098
									],
									[
										8132,
										8143
									],
									[
										8176,
										8187
									],
									[
										8327,
										8338
									],
									[
										8599,
										8610
									],
									[
										8899,
										8910
									],
									[
										9080,
										9091
									],
									[
										9259,
										9270
									],
									[
										9402,
										9413
									],
									[
										9527,
										9538
									],
									[
										9709,
										9720
									],
									[
										9926,
										9937
									],
									[
										10046,
										10057
									],
									[
										10176,
										10187
									],
									[
										10361,
										10372
									],
									[
										10505,
										10516
									],
									[
										10639,
										10650
									],
									[
										10761,
										10772
									],
									[
										10881,
										10892
									],
									[
										10999,
										11010
									],
									[
										11196,
										11207
									],
									[
										11385,
										11396
									],
									[
										11511,
										11522
									],
									[
										11672,
										11683
									],
									[
										11804,
										11815
									],
									[
										11936,
										11947
									],
									[
										12062,
										12073
									],
									[
										12267,
										12278
									],
									[
										12305,
										12316
									],
									[
										12343,
										12354
									],
									[
										12381,
										12392
									],
									[
										12419,
										12430
									],
									[
										12521,
										12532
									],
									[
										12616,
										12627
									],
									[
										12650,
										12661
									],
									[
										12772,
										12783
									],
									[
										12813,
										12824
									],
									[
										12854,
										12865
									],
									[
										12895,
										12906
									],
									[
										12991,
										13002
									],
									[
										13022,
										13033
									],
									[
										13060,
										13071
									],
									[
										13097,
										13108
									],
									[
										13135,
										13146
									],
									[
										13168,
										13179
									],
									[
										13296,
										13307
									],
									[
										13330,
										13341
									],
									[
										13367,
										13378
									],
									[
										13405,
										13416
									],
									[
										13546,
										13557
									],
									[
										13589,
										13600
									],
									[
										13728,
										13739
									],
									[
										13764,
										13775
									],
									[
										13886,
										13897
									],
									[
										14081,
										14092
									],
									[
										14259,
										14270
									],
									[
										14519,
										14530
									],
									[
										14658,
										14669
									],
									[
										14853,
										14864
									],
									[
										15010,
										15021
									],
									[
										15113,
										15124
									],
									[
										15228,
										15239
									],
									[
										15319,
										15330
									],
									[
										15602,
										15613
									],
									[
										15858,
										15869
									],
									[
										15908,
										15919
									],
									[
										16126,
										16137
									],
									[
										16321,
										16332
									],
									[
										16570,
										16581
									],
									[
										16763,
										16774
									],
									[
										16921,
										16932
									],
									[
										17084,
										17095
									],
									[
										17224,
										17235
									],
									[
										17517,
										17528
									],
									[
										17812,
										17823
									],
									[
										18088,
										18099
									],
									[
										18282,
										18293
									],
									[
										18485,
										18496
									],
									[
										18677,
										18688
									],
									[
										18716,
										18727
									],
									[
										18760,
										18771
									],
									[
										18803,
										18814
									],
									[
										18962,
										18973
									],
									[
										19004,
										19015
									],
									[
										19149,
										19160
									],
									[
										19188,
										19199
									],
									[
										19234,
										19245
									],
									[
										19377,
										19388
									],
									[
										19415,
										19426
									],
									[
										19460,
										19471
									],
									[
										19641,
										19652
									],
									[
										19686,
										19697
									],
									[
										19731,
										19742
									],
									[
										19775,
										19786
									],
									[
										19926,
										19937
									],
									[
										20198,
										20209
									],
									[
										20498,
										20509
									],
									[
										20679,
										20690
									],
									[
										20858,
										20869
									],
									[
										21001,
										21012
									],
									[
										21126,
										21137
									],
									[
										21308,
										21319
									],
									[
										21525,
										21536
									],
									[
										21645,
										21656
									],
									[
										21775,
										21786
									],
									[
										21960,
										21971
									],
									[
										22104,
										22115
									],
									[
										22238,
										22249
									],
									[
										22360,
										22371
									],
									[
										22480,
										22491
									],
									[
										22598,
										22609
									],
									[
										22795,
										22806
									],
									[
										22984,
										22995
									],
									[
										23110,
										23121
									],
									[
										23271,
										23282
									],
									[
										23403,
										23414
									],
									[
										23535,
										23546
									],
									[
										23661,
										23672
									],
									[
										23866,
										23877
									],
									[
										23904,
										23915
									],
									[
										23942,
										23953
									],
									[
										23980,
										23991
									],
									[
										24018,
										24029
									],
									[
										24120,
										24131
									],
									[
										24215,
										24226
									],
									[
										24249,
										24260
									],
									[
										24371,
										24382
									],
									[
										24412,
										24423
									],
									[
										24453,
										24464
									],
									[
										24494,
										24505
									],
									[
										24590,
										24601
									],
									[
										24621,
										24632
									],
									[
										24659,
										24670
									],
									[
										24696,
										24707
									],
									[
										24734,
										24745
									],
									[
										24767,
										24778
									],
									[
										24895,
										24906
									],
									[
										24929,
										24940
									],
									[
										24966,
										24977
									],
									[
										25004,
										25015
									],
									[
										25145,
										25156
									],
									[
										25188,
										25199
									],
									[
										25327,
										25338
									],
									[
										25363,
										25374
									],
									[
										25485,
										25496
									],
									[
										25680,
										25691
									],
									[
										25858,
										25869
									],
									[
										26118,
										26129
									],
									[
										26257,
										26268
									],
									[
										26452,
										26463
									],
									[
										26609,
										26620
									],
									[
										26712,
										26723
									],
									[
										26827,
										26838
									],
									[
										26918,
										26929
									],
									[
										27128,
										27139
									],
									[
										27323,
										27334
									],
									[
										27572,
										27583
									],
									[
										27765,
										27776
									],
									[
										27923,
										27934
									],
									[
										28086,
										28097
									],
									[
										28226,
										28237
									],
									[
										28519,
										28530
									],
									[
										28814,
										28825
									],
									[
										29090,
										29101
									],
									[
										29284,
										29295
									],
									[
										29487,
										29498
									],
									[
										29679,
										29690
									],
									[
										29718,
										29729
									],
									[
										29762,
										29773
									],
									[
										29805,
										29816
									],
									[
										29964,
										29975
									],
									[
										30006,
										30017
									],
									[
										30151,
										30162
									],
									[
										30190,
										30201
									],
									[
										30236,
										30247
									],
									[
										30379,
										30390
									],
									[
										30417,
										30428
									],
									[
										30462,
										30473
									],
									[
										30643,
										30654
									],
									[
										30688,
										30699
									],
									[
										30733,
										30744
									],
									[
										30777,
										30788
									],
									[
										30928,
										30939
									],
									[
										31200,
										31211
									],
									[
										31500,
										31511
									],
									[
										31681,
										31692
									],
									[
										31860,
										31871
									],
									[
										32003,
										32014
									],
									[
										32128,
										32139
									],
									[
										32310,
										32321
									],
									[
										32527,
										32538
									],
									[
										32647,
										32658
									],
									[
										32777,
										32788
									],
									[
										32962,
										32973
									],
									[
										33106,
										33117
									],
									[
										33240,
										33251
									],
									[
										33362,
										33373
									],
									[
										33482,
										33493
									],
									[
										33600,
										33611
									],
									[
										33797,
										33808
									],
									[
										33986,
										33997
									],
									[
										34112,
										34123
									],
									[
										34273,
										34284
									],
									[
										34405,
										34416
									],
									[
										34537,
										34548
									],
									[
										34663,
										34674
									],
									[
										34868,
										34879
									],
									[
										34906,
										34917
									],
									[
										34944,
										34955
									],
									[
										34982,
										34993
									],
									[
										35020,
										35031
									],
									[
										35122,
										35133
									],
									[
										35217,
										35228
									],
									[
										35251,
										35262
									],
									[
										35373,
										35384
									],
									[
										35414,
										35425
									],
									[
										35455,
										35466
									],
									[
										35496,
										35507
									],
									[
										35592,
										35603
									],
									[
										35623,
										35634
									],
									[
										35661,
										35672
									],
									[
										35698,
										35709
									],
									[
										35736,
										35747
									],
									[
										35769,
										35780
									],
									[
										35897,
										35908
									],
									[
										35931,
										35942
									],
									[
										35968,
										35979
									],
									[
										36006,
										36017
									],
									[
										36147,
										36158
									],
									[
										36190,
										36201
									],
									[
										36329,
										36340
									],
									[
										36365,
										36376
									],
									[
										36487,
										36498
									],
									[
										36682,
										36693
									],
									[
										36860,
										36871
									],
									[
										37120,
										37131
									],
									[
										37259,
										37270
									],
									[
										37454,
										37465
									],
									[
										37611,
										37622
									],
									[
										37714,
										37725
									],
									[
										37829,
										37840
									],
									[
										37920,
										37931
									],
									[
										38177,
										38188
									],
									[
										38370,
										38381
									],
									[
										38528,
										38539
									],
									[
										38691,
										38702
									],
									[
										38831,
										38842
									],
									[
										39124,
										39135
									],
									[
										39419,
										39430
									],
									[
										39695,
										39706
									],
									[
										39889,
										39900
									],
									[
										40092,
										40103
									],
									[
										40284,
										40295
									],
									[
										40323,
										40334
									],
									[
										40367,
										40378
									],
									[
										40410,
										40421
									],
									[
										40569,
										40580
									],
									[
										40611,
										40622
									],
									[
										40756,
										40767
									],
									[
										40795,
										40806
									],
									[
										40841,
										40852
									],
									[
										40984,
										40995
									],
									[
										41022,
										41033
									],
									[
										41067,
										41078
									],
									[
										41248,
										41259
									],
									[
										41293,
										41304
									],
									[
										41338,
										41349
									],
									[
										41382,
										41393
									],
									[
										41533,
										41544
									],
									[
										41805,
										41816
									],
									[
										42105,
										42116
									],
									[
										42286,
										42297
									],
									[
										42465,
										42476
									],
									[
										42608,
										42619
									],
									[
										42733,
										42744
									],
									[
										42915,
										42926
									],
									[
										43132,
										43143
									],
									[
										43252,
										43263
									],
									[
										43382,
										43393
									],
									[
										43567,
										43578
									],
									[
										43711,
										43722
									],
									[
										43845,
										43856
									],
									[
										43967,
										43978
									],
									[
										44087,
										44098
									],
									[
										44205,
										44216
									],
									[
										44402,
										44413
									],
									[
										44591,
										44602
									],
									[
										44717,
										44728
									],
									[
										44878,
										44889
									],
									[
										45010,
										45021
									],
									[
										45142,
										45153
									],
									[
										45268,
										45279
									],
									[
										45473,
										45484
									],
									[
										45511,
										45522
									],
									[
										45549,
										45560
									],
									[
										45587,
										45598
									],
									[
										45625,
										45636
									],
									[
										45727,
										45738
									],
									[
										45822,
										45833
									],
									[
										45856,
										45867
									],
									[
										45978,
										45989
									],
									[
										46019,
										46030
									],
									[
										46060,
										46071
									],
									[
										46101,
										46112
									],
									[
										46197,
										46208
									],
									[
										46228,
										46239
									],
									[
										46266,
										46277
									],
									[
										46303,
										46314
									],
									[
										46341,
										46352
									],
									[
										46374,
										46385
									],
									[
										46502,
										46513
									],
									[
										46536,
										46547
									],
									[
										46573,
										46584
									],
									[
										46611,
										46622
									],
									[
										46752,
										46763
									],
									[
										46795,
										46806
									],
									[
										46934,
										46945
									],
									[
										46970,
										46981
									],
									[
										47092,
										47103
									],
									[
										47287,
										47298
									],
									[
										47465,
										47476
									],
									[
										47725,
										47736
									],
									[
										47864,
										47875
									],
									[
										48059,
										48070
									],
									[
										48216,
										48227
									],
									[
										48319,
										48330
									],
									[
										48434,
										48445
									],
									[
										48525,
										48536
									],
									[
										48782,
										48793
									],
									[
										49052,
										49063
									],
									[
										49347,
										49358
									],
									[
										49623,
										49634
									],
									[
										49817,
										49828
									],
									[
										50020,
										50031
									],
									[
										50212,
										50223
									],
									[
										50251,
										50262
									],
									[
										50295,
										50306
									],
									[
										50338,
										50349
									],
									[
										50497,
										50508
									],
									[
										50539,
										50550
									],
									[
										50684,
										50695
									],
									[
										50723,
										50734
									],
									[
										50769,
										50780
									],
									[
										50912,
										50923
									],
									[
										50950,
										50961
									],
									[
										50995,
										51006
									],
									[
										51176,
										51187
									],
									[
										51221,
										51232
									],
									[
										51266,
										51277
									],
									[
										51310,
										51321
									],
									[
										51461,
										51472
									],
									[
										51733,
										51744
									],
									[
										52033,
										52044
									],
									[
										52214,
										52225
									],
									[
										52393,
										52404
									],
									[
										52536,
										52547
									],
									[
										52661,
										52672
									],
									[
										52843,
										52854
									],
									[
										53060,
										53071
									],
									[
										53180,
										53191
									],
									[
										53310,
										53321
									],
									[
										53495,
										53506
									],
									[
										53639,
										53650
									],
									[
										53773,
										53784
									],
									[
										53895,
										53906
									],
									[
										54015,
										54026
									],
									[
										54133,
										54144
									],
									[
										54330,
										54341
									],
									[
										54519,
										54530
									],
									[
										54645,
										54656
									],
									[
										54806,
										54817
									],
									[
										54938,
										54949
									],
									[
										55070,
										55081
									],
									[
										55196,
										55207
									],
									[
										55401,
										55412
									],
									[
										55439,
										55450
									],
									[
										55477,
										55488
									],
									[
										55515,
										55526
									],
									[
										55553,
										55564
									],
									[
										55655,
										55666
									],
									[
										55750,
										55761
									],
									[
										55784,
										55795
									],
									[
										55906,
										55917
									],
									[
										55947,
										55958
									],
									[
										55988,
										55999
									],
									[
										56029,
										56040
									],
									[
										56125,
										56136
									],
									[
										56156,
										56167
									],
									[
										56194,
										56205
									],
									[
										56231,
										56242
									],
									[
										56269,
										56280
									],
									[
										56302,
										56313
									],
									[
										56430,
										56441
									],
									[
										56464,
										56475
									],
									[
										56501,
										56512
									],
									[
										56539,
										56550
									],
									[
										56680,
										56691
									],
									[
										56723,
										56734
									],
									[
										56862,
										56873
									],
									[
										56898,
										56909
									],
									[
										57020,
										57031
									],
									[
										57215,
										57226
									],
									[
										57393,
										57404
									],
									[
										57653,
										57664
									],
									[
										57792,
										57803
									],
									[
										57987,
										57998
									],
									[
										58144,
										58155
									],
									[
										58247,
										58258
									],
									[
										58362,
										58373
									],
									[
										58453,
										58464
									],
									[
										58710,
										58721
									],
									[
										58856,
										58867
									],
									[
										59059,
										59070
									],
									[
										59251,
										59262
									],
									[
										59290,
										59301
									],
									[
										59334,
										59345
									],
									[
										59377,
										59388
									],
									[
										59536,
										59547
									],
									[
										59578,
										59589
									],
									[
										59723,
										59734
									],
									[
										59762,
										59773
									],
									[
										59808,
										59819
									],
									[
										59951,
										59962
									],
									[
										59989,
										60000
									],
									[
										60034,
										60045
									],
									[
										60215,
										60226
									],
									[
										60260,
										60271
									],
									[
										60305,
										60316
									],
									[
										60349,
										60360
									],
									[
										60500,
										60511
									],
									[
										60772,
										60783
									],
									[
										61072,
										61083
									],
									[
										61253,
										61264
									],
									[
										61432,
										61443
									],
									[
										61575,
										61586
									],
									[
										61700,
										61711
									],
									[
										61882,
										61893
									],
									[
										62099,
										62110
									],
									[
										62219,
										62230
									],
									[
										62349,
										62360
									],
									[
										62534,
										62545
									],
									[
										62678,
										62689
									],
									[
										62812,
										62823
									],
									[
										62934,
										62945
									],
									[
										63054,
										63065
									],
									[
										63172,
										63183
									],
									[
										63369,
										63380
									],
									[
										63558,
										63569
									],
									[
										63684,
										63695
									],
									[
										63845,
										63856
									],
									[
										63977,
										63988
									],
									[
										64109,
										64120
									],
									[
										64235,
										64246
									],
									[
										64440,
										64451
									],
									[
										64478,
										64489
									],
									[
										64516,
										64527
									],
									[
										64554,
										64565
									],
									[
										64592,
										64603
									],
									[
										64694,
										64705
									],
									[
										64789,
										64800
									],
									[
										64823,
										64834
									],
									[
										64945,
										64956
									],
									[
										64986,
										64997
									],
									[
										65027,
										65038
									],
									[
										65068,
										65079
									],
									[
										65164,
										65175
									],
									[
										65195,
										65206
									],
									[
										65233,
										65244
									],
									[
										65270,
										65281
									],
									[
										65308,
										65319
									],
									[
										65341,
										65352
									],
									[
										65469,
										65480
									],
									[
										65503,
										65514
									],
									[
										65540,
										65551
									],
									[
										65578,
										65589
									],
									[
										65719,
										65730
									],
									[
										65762,
										65773
									],
									[
										65901,
										65912
									],
									[
										65937,
										65948
									],
									[
										66059,
										66070
									],
									[
										66254,
										66265
									],
									[
										66432,
										66443
									],
									[
										66692,
										66703
									],
									[
										66831,
										66842
									],
									[
										67026,
										67037
									],
									[
										67183,
										67194
									],
									[
										67286,
										67297
									],
									[
										67401,
										67412
									],
									[
										67492,
										67503
									],
									[
										67749,
										67760
									],
									[
										67934,
										67945
									],
									[
										68126,
										68137
									],
									[
										68165,
										68176
									],
									[
										68209,
										68220
									],
									[
										68252,
										68263
									],
									[
										68411,
										68422
									],
									[
										68453,
										68464
									],
									[
										68598,
										68609
									],
									[
										68637,
										68648
									],
									[
										68683,
										68694
									],
									[
										68826,
										68837
									],
									[
										68864,
										68875
									],
									[
										68909,
										68920
									],
									[
										69090,
										69101
									],
									[
										69135,
										69146
									],
									[
										69180,
										69191
									],
									[
										69224,
										69235
									],
									[
										69375,
										69386
									],
									[
										69647,
										69658
									],
									[
										69947,
										69958
									],
									[
										70128,
										70139
									],
									[
										70307,
										70318
									],
									[
										70450,
										70461
									],
									[
										70575,
										70586
									],
									[
										70757,
										70768
									],
									[
										70974,
										70985
									],
									[
										71094,
										71105
									],
									[
										71224,
										71235
									],
									[
										71409,
										71420
									],
									[
										71553,
										71564
									],
									[
										71687,
										71698
									],
									[
										71809,
										71820
									],
									[
										71929,
										71940
									],
									[
										72047,
										72058
									],
									[
										72244,
										72255
									],
									[
										72433,
										72444
									],
									[
										72559,
										72570
									],
									[
										72720,
										72731
									],
									[
										72852,
										72863
									],
									[
										72984,
										72995
									],
									[
										73110,
										73121
									],
									[
										73315,
										73326
									],
									[
										73353,
										73364
									],
									[
										73391,
										73402
									],
									[
										73429,
										73440
									],
									[
										73467,
										73478
									],
									[
										73569,
										73580
									],
									[
										73664,
										73675
									],
									[
										73698,
										73709
									],
									[
										73820,
										73831
									],
									[
										73861,
										73872
									],
									[
										73902,
										73913
									],
									[
										73943,
										73954
									],
									[
										74039,
										74050
									],
									[
										74070,
										74081
									],
									[
										74108,
										74119
									],
									[
										74145,
										74156
									],
									[
										74183,
										74194
									],
									[
										74216,
										74227
									],
									[
										74344,
										74355
									],
									[
										74378,
										74389
									],
									[
										74415,
										74426
									],
									[
										74453,
										74464
									],
									[
										74594,
										74605
									],
									[
										74637,
										74648
									],
									[
										74776,
										74787
									],
									[
										74812,
										74823
									],
									[
										74934,
										74945
									],
									[
										75129,
										75140
									],
									[
										75307,
										75318
									],
									[
										75567,
										75578
									],
									[
										75706,
										75717
									],
									[
										75901,
										75912
									],
									[
										76058,
										76069
									],
									[
										76161,
										76172
									],
									[
										76276,
										76287
									],
									[
										76367,
										76378
									],
									[
										76623,
										76634
									],
									[
										76856,
										76867
									],
									[
										77156,
										77167
									],
									[
										77337,
										77348
									],
									[
										77516,
										77527
									],
									[
										77659,
										77670
									],
									[
										77784,
										77795
									],
									[
										77966,
										77977
									],
									[
										78183,
										78194
									],
									[
										78303,
										78314
									],
									[
										78433,
										78444
									],
									[
										78618,
										78629
									],
									[
										78762,
										78773
									],
									[
										78896,
										78907
									],
									[
										79018,
										79029
									],
									[
										79138,
										79149
									],
									[
										79256,
										79267
									],
									[
										79453,
										79464
									],
									[
										79642,
										79653
									],
									[
										79768,
										79779
									],
									[
										79929,
										79940
									],
									[
										80061,
										80072
									],
									[
										80193,
										80204
									],
									[
										80319,
										80330
									],
									[
										80524,
										80535
									],
									[
										80562,
										80573
									],
									[
										80600,
										80611
									],
									[
										80638,
										80649
									],
									[
										80676,
										80687
									],
									[
										80778,
										80789
									],
									[
										80873,
										80884
									],
									[
										80907,
										80918
									],
									[
										81029,
										81040
									],
									[
										81070,
										81081
									],
									[
										81111,
										81122
									],
									[
										81152,
										81163
									],
									[
										81248,
										81259
									],
									[
										81279,
										81290
									],
									[
										81317,
										81328
									],
									[
										81354,
										81365
									],
									[
										81392,
										81403
									],
									[
										81425,
										81436
									],
									[
										81553,
										81564
									],
									[
										81587,
										81598
									],
									[
										81624,
										81635
									],
									[
										81662,
										81673
									],
									[
										81803,
										81814
									],
									[
										81846,
										81857
									],
									[
										81985,
										81996
									],
									[
										82021,
										82032
									],
									[
										82143,
										82154
									],
									[
										82338,
										82349
									],
									[
										82516,
										82527
									],
									[
										82776,
										82787
									],
									[
										82915,
										82926
									],
									[
										83110,
										83121
									],
									[
										83267,
										83278
									],
									[
										83370,
										83381
									],
									[
										83485,
										83496
									],
									[
										83576,
										83587
									],
									[
										83832,
										83843
									],
									[
										84065,
										84076
									],
									[
										84296,
										84307
									],
									[
										84416,
										84427
									],
									[
										84546,
										84557
									],
									[
										84731,
										84742
									],
									[
										84875,
										84886
									],
									[
										85009,
										85020
									],
									[
										85131,
										85142
									],
									[
										85251,
										85262
									],
									[
										85369,
										85380
									],
									[
										85566,
										85577
									],
									[
										85755,
										85766
									],
									[
										85881,
										85892
									],
									[
										86042,
										86053
									],
									[
										86174,
										86185
									],
									[
										86306,
										86317
									],
									[
										86432,
										86443
									],
									[
										86637,
										86648
									],
									[
										86675,
										86686
									],
									[
										86713,
										86724
									],
									[
										86751,
										86762
									],
									[
										86789,
										86800
									],
									[
										86891,
										86902
									],
									[
										86986,
										86997
									],
									[
										87020,
										87031
									],
									[
										87142,
										87153
									],
									[
										87183,
										87194
									],
									[
										87224,
										87235
									],
									[
										87265,
										87276
									],
									[
										87361,
										87372
									],
									[
										87392,
										87403
									],
									[
										87430,
										87441
									],
									[
										87467,
										87478
									],
									[
										87505,
										87516
									],
									[
										87538,
										87549
									],
									[
										87666,
										87677
									],
									[
										87700,
										87711
									],
									[
										87737,
										87748
									],
									[
										87775,
										87786
									],
									[
										87916,
										87927
									],
									[
										87959,
										87970
									],
									[
										88098,
										88109
									],
									[
										88134,
										88145
									],
									[
										88256,
										88267
									],
									[
										88451,
										88462
									],
									[
										88629,
										88640
									],
									[
										88889,
										88900
									],
									[
										89028,
										89039
									],
									[
										89223,
										89234
									],
									[
										89380,
										89391
									],
									[
										89483,
										89494
									],
									[
										89598,
										89609
									],
									[
										89689,
										89700
									],
									[
										89945,
										89956
									],
									[
										90178,
										90189
									],
									[
										90409,
										90420
									],
									[
										90447,
										90458
									],
									[
										90485,
										90496
									],
									[
										90523,
										90534
									],
									[
										90561,
										90572
									],
									[
										90663,
										90674
									],
									[
										90758,
										90769
									],
									[
										90792,
										90803
									],
									[
										90914,
										90925
									],
									[
										90955,
										90966
									],
									[
										90996,
										91007
									],
									[
										91037,
										91048
									],
									[
										91133,
										91144
									],
									[
										91164,
										91175
									],
									[
										91202,
										91213
									],
									[
										91239,
										91250
									],
									[
										91277,
										91288
									],
									[
										91310,
										91321
									],
									[
										91438,
										91449
									],
									[
										91472,
										91483
									],
									[
										91509,
										91520
									],
									[
										91547,
										91558
									],
									[
										91688,
										91699
									],
									[
										91731,
										91742
									],
									[
										91870,
										91881
									],
									[
										91906,
										91917
									],
									[
										92028,
										92039
									],
									[
										92223,
										92234
									],
									[
										92401,
										92412
									],
									[
										92661,
										92672
									],
									[
										92800,
										92811
									],
									[
										92995,
										93006
									],
									[
										93152,
										93163
									],
									[
										93255,
										93266
									],
									[
										93370,
										93381
									],
									[
										93461,
										93472
									],
									[
										93717,
										93728
									],
									[
										93950,
										93961
									],
									[
										94226,
										94237
									],
									[
										94404,
										94415
									],
									[
										94664,
										94675
									],
									[
										94803,
										94814
									],
									[
										94998,
										95009
									],
									[
										95155,
										95166
									],
									[
										95258,
										95269
									],
									[
										95373,
										95384
									],
									[
										95464,
										95475
									],
									[
										95720,
										95731
									],
									[
										95953,
										95964
									],
									[
										96257,
										96268
									],
									[
										96396,
										96407
									],
									[
										96591,
										96602
									],
									[
										96748,
										96759
									],
									[
										96851,
										96862
									],
									[
										96966,
										96977
									],
									[
										97057,
										97068
									],
									[
										97312,
										97323
									],
									[
										97545,
										97556
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								97322,
								97322
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 13,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 68077.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/db.c",
					"settings":
					{
						"buffer_size": 84105,
						"regions":
						{
						},
						"selection":
						[
							[
								67596,
								67596
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 59140.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 145.0,
	"status_bar_visible": true
}
